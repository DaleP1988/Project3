{"ast":null,"code":"var select = require('xpath.js'),\n    Dom = require('xmldom').DOMParser,\n    utils = require('./utils'),\n    ExclusiveCanonicalization = require('./exclusive-canonicalization').ExclusiveCanonicalization,\n    ExclusiveCanonicalizationWithComments = require('./exclusive-canonicalization').ExclusiveCanonicalizationWithComments,\n    EnvelopedSignature = require('./enveloped-signature').EnvelopedSignature,\n    crypto = require('crypto'),\n    fs = require('fs');\n\nexports.SignedXml = SignedXml;\nexports.FileKeyInfo = FileKeyInfo;\n/**\n * A key info provider implementation\n *\n */\n\nfunction FileKeyInfo(file) {\n  this.file = file;\n\n  this.getKeyInfo = function (key, prefix) {\n    prefix = prefix || '';\n    prefix = prefix ? prefix + ':' : prefix;\n    return \"<\" + prefix + \"X509Data></\" + prefix + \"X509Data>\";\n  };\n\n  this.getKey = function (keyInfo) {\n    return fs.readFileSync(this.file);\n  };\n}\n/**\n * Hash algorithm implementation\n *\n */\n\n\nfunction SHA1() {\n  this.getHash = function (xml) {\n    var shasum = crypto.createHash('sha1');\n    shasum.update(xml, 'utf8');\n    var res = shasum.digest('base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2000/09/xmldsig#sha1\";\n  };\n}\n\nfunction SHA256() {\n  this.getHash = function (xml) {\n    var shasum = crypto.createHash('sha256');\n    shasum.update(xml, 'utf8');\n    var res = shasum.digest('base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmlenc#sha256\";\n  };\n}\n\nfunction SHA512() {\n  this.getHash = function (xml) {\n    var shasum = crypto.createHash('sha512');\n    shasum.update(xml, 'utf8');\n    var res = shasum.digest('base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmlenc#sha512\";\n  };\n}\n/**\n * Signature algorithm implementation\n *\n */\n\n\nfunction RSASHA1() {\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function (signedInfo, signingKey) {\n    var signer = crypto.createSign(\"RSA-SHA1\");\n    signer.update(signedInfo);\n    var res = signer.sign(signingKey, 'base64');\n    return res;\n  };\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n\n\n  this.verifySignature = function (str, key, signatureValue) {\n    var verifier = crypto.createVerify(\"RSA-SHA1\");\n    verifier.update(str);\n    var res = verifier.verify(key, signatureValue, 'base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\";\n  };\n}\n/**\n * Signature algorithm implementation\n *\n */\n\n\nfunction RSASHA256() {\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function (signedInfo, signingKey) {\n    var signer = crypto.createSign(\"RSA-SHA256\");\n    signer.update(signedInfo);\n    var res = signer.sign(signingKey, 'base64');\n    return res;\n  };\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n\n\n  this.verifySignature = function (str, key, signatureValue) {\n    var verifier = crypto.createVerify(\"RSA-SHA256\");\n    verifier.update(str);\n    var res = verifier.verify(key, signatureValue, 'base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\";\n  };\n}\n/**\n * Signature algorithm implementation\n *\n */\n\n\nfunction RSASHA512() {\n  /**\n  * Sign the given string using the given key\n  *\n  */\n  this.getSignature = function (signedInfo, signingKey) {\n    var signer = crypto.createSign(\"RSA-SHA512\");\n    signer.update(signedInfo);\n    var res = signer.sign(signingKey, 'base64');\n    return res;\n  };\n  /**\n  * Verify the given signature of the given string using key\n  *\n  */\n\n\n  this.verifySignature = function (str, key, signatureValue) {\n    var verifier = crypto.createVerify(\"RSA-SHA512\");\n    verifier.update(str);\n    var res = verifier.verify(key, signatureValue, 'base64');\n    return res;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\";\n  };\n}\n\nfunction HMACSHA1() {\n  this.verifySignature = function (str, key, signatureValue) {\n    var verifier = crypto.createHmac(\"SHA1\", key);\n    verifier.update(str);\n    var res = verifier.digest('base64');\n    return res === signatureValue;\n  };\n\n  this.getAlgorithmName = function () {\n    return \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\";\n  };\n\n  this.getSignature = function (signedInfo, signingKey) {\n    var verifier = crypto.createHmac(\"SHA1\", signingKey);\n    verifier.update(signedInfo);\n    var res = verifier.digest('base64');\n    return res;\n  };\n}\n/**\n* Xml signature implementation\n*\n* @param {string} idMode. Value of \"wssecurity\" will create/validate id's with the ws-security namespace\n*/\n\n\nfunction SignedXml(idMode, options) {\n  this.options = options || {};\n  this.idMode = idMode;\n  this.references = [];\n  this.id = 0;\n  this.signingKey = null;\n  this.signatureAlgorithm = this.options.signatureAlgorithm || \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\";\n  this.keyInfoProvider = null;\n  this.canonicalizationAlgorithm = \"http://www.w3.org/2001/10/xml-exc-c14n#\";\n  this.signedXml = \"\";\n  this.signatureXml = \"\";\n  this.signatureNode = null;\n  this.signatureValue = \"\";\n  this.originalXmlWithIds = \"\";\n  this.validationErrors = [];\n  this.keyInfo = null;\n  this.idAttributes = ['Id', 'ID', 'id'];\n  if (this.options.idAttribute) this.idAttributes.splice(0, 0, this.options.idAttribute);\n}\n\nSignedXml.CanonicalizationAlgorithms = {\n  'http://www.w3.org/2001/10/xml-exc-c14n#': ExclusiveCanonicalization,\n  'http://www.w3.org/2001/10/xml-exc-c14n#WithComments': ExclusiveCanonicalizationWithComments,\n  'http://www.w3.org/2000/09/xmldsig#enveloped-signature': EnvelopedSignature\n};\nSignedXml.HashAlgorithms = {\n  'http://www.w3.org/2000/09/xmldsig#sha1': SHA1,\n  'http://www.w3.org/2001/04/xmlenc#sha256': SHA256,\n  'http://www.w3.org/2001/04/xmlenc#sha512': SHA512\n};\nSignedXml.SignatureAlgorithms = {\n  'http://www.w3.org/2000/09/xmldsig#rsa-sha1': RSASHA1,\n  'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256': RSASHA256,\n  'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512': RSASHA512,\n  'http://www.w3.org/2000/09/xmldsig#hmac-sha1': HMACSHA1\n};\nSignedXml.defaultNsForPrefix = {\n  ds: 'http://www.w3.org/2000/09/xmldsig#'\n};\n\nSignedXml.prototype.checkSignature = function (xml) {\n  this.validationErrors = [];\n  this.signedXml = xml;\n\n  if (!this.keyInfoProvider) {\n    throw new Error(\"cannot validate signature since no key info resolver was provided\");\n  }\n\n  this.signingKey = this.keyInfoProvider.getKey(this.keyInfo);\n  if (!this.signingKey) throw new Error(\"key info provider could not resolve key info \" + this.keyInfo);\n  var doc = new Dom().parseFromString(xml);\n\n  if (!this.validateReferences(doc)) {\n    return false;\n  }\n\n  if (!this.validateSignatureValue()) {\n    return false;\n  }\n\n  return true;\n};\n\nSignedXml.prototype.validateSignatureValue = function () {\n  var signedInfo = utils.findChilds(this.signatureNode, \"SignedInfo\");\n  if (signedInfo.length == 0) throw new Error(\"could not find SignedInfo element in the message\");\n  var signedInfoCanon = this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0]);\n  var signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n  var res = signer.verifySignature(signedInfoCanon, this.signingKey, this.signatureValue);\n  if (!res) this.validationErrors.push(\"invalid signature: the signature value \" + this.signatureValue + \" is incorrect\");\n  return res;\n};\n\nSignedXml.prototype.findSignatureAlgorithm = function (name) {\n  var algo = SignedXml.SignatureAlgorithms[name];\n  if (algo) return new algo();else throw new Error(\"signature algorithm '\" + name + \"' is not supported\");\n};\n\nSignedXml.prototype.findCanonicalizationAlgorithm = function (name) {\n  var algo = SignedXml.CanonicalizationAlgorithms[name];\n  if (algo) return new algo();else throw new Error(\"canonicalization algorithm '\" + name + \"' is not supported\");\n};\n\nSignedXml.prototype.findHashAlgorithm = function (name) {\n  var algo = SignedXml.HashAlgorithms[name];\n  if (algo) return new algo();else throw new Error(\"hash algorithm '\" + name + \"' is not supported\");\n};\n\nSignedXml.prototype.validateReferences = function (doc) {\n  for (var r in this.references) {\n    if (!this.references.hasOwnProperty(r)) continue;\n    var ref = this.references[r];\n    var uri = ref.uri[0] == \"#\" ? ref.uri.substring(1) : ref.uri;\n    var elem = [];\n\n    if (uri == \"\") {\n      elem = select(doc, \"//*\");\n    } else {\n      for (var index in this.idAttributes) {\n        if (!this.idAttributes.hasOwnProperty(index)) continue;\n        elem = select(doc, \"//*[@*[local-name(.)='\" + this.idAttributes[index] + \"']='\" + uri + \"']\");\n        if (elem.length > 0) break;\n      }\n    }\n\n    if (elem.length == 0) {\n      this.validationErrors.push(\"invalid signature: the signature refernces an element with uri \" + ref.uri + \" but could not find such element in the xml\");\n      return false;\n    }\n\n    var canonXml = this.getCanonXml(ref.transforms, elem[0], {\n      inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList\n    });\n    var hash = this.findHashAlgorithm(ref.digestAlgorithm);\n    var digest = hash.getHash(canonXml);\n\n    if (digest != ref.digestValue) {\n      this.validationErrors.push(\"invalid signature: for uri \" + ref.uri + \" calculated digest is \" + digest + \" but the xml to validate supplies digest \" + ref.digestValue);\n      return false;\n    }\n  }\n\n  return true;\n};\n\nSignedXml.prototype.loadSignature = function (signatureNode) {\n  if (typeof signatureNode === 'string') {\n    this.signatureNode = signatureNode = new Dom().parseFromString(signatureNode);\n  } else {\n    this.signatureNode = signatureNode;\n  }\n\n  this.signatureXml = signatureNode.toString();\n  var nodes = select(signatureNode, \".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\");\n  if (nodes.length == 0) throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\");\n  this.canonicalizationAlgorithm = nodes[0].value;\n  this.signatureAlgorithm = utils.findFirst(signatureNode, \".//*[local-name(.)='SignatureMethod']/@Algorithm\").value;\n  this.references = [];\n  var references = select(signatureNode, \".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']\");\n  if (references.length == 0) throw new Error(\"could not find any Reference elements\");\n\n  for (var i in references) {\n    if (!references.hasOwnProperty(i)) continue;\n    this.loadReference(references[i]);\n  }\n\n  this.signatureValue = utils.findFirst(signatureNode, \".//*[local-name(.)='SignatureValue']/text()\").data.replace(/\\r?\\n/g, '');\n  this.keyInfo = select(signatureNode, \".//*[local-name(.)='KeyInfo']\");\n};\n/**\n * Load the reference xml node to a model\n *\n */\n\n\nSignedXml.prototype.loadReference = function (ref) {\n  var nodes = utils.findChilds(ref, \"DigestMethod\");\n  if (nodes.length == 0) throw new Error(\"could not find DigestMethod in reference \" + ref.toString());\n  var digestAlgoNode = nodes[0];\n  var attr = utils.findAttr(digestAlgoNode, \"Algorithm\");\n  if (!attr) throw new Error(\"could not find Algorithm attribute in node \" + digestAlgoNode.toString());\n  var digestAlgo = attr.value;\n  nodes = utils.findChilds(ref, \"DigestValue\");\n  if (nodes.length == 0) throw new Error(\"could not find DigestValue node in reference \" + ref.toString());\n\n  if (nodes[0].childNodes.length == 0 || !nodes[0].firstChild.data) {\n    throw new Error(\"could not find the value of DigestValue in \" + nodes[0].toString());\n  }\n\n  var digestValue = nodes[0].firstChild.data;\n  var transforms = [];\n  var inclusiveNamespacesPrefixList;\n  nodes = utils.findChilds(ref, \"Transforms\");\n\n  if (nodes.length != 0) {\n    var transformsNode = nodes[0];\n    var transformsAll = utils.findChilds(transformsNode, \"Transform\");\n\n    for (var t in transformsAll) {\n      if (!transformsAll.hasOwnProperty(t)) continue;\n      var trans = transformsAll[t];\n      transforms.push(utils.findAttr(trans, \"Algorithm\").value);\n    }\n\n    var inclusiveNamespaces = select(transformsNode, \"//*[local-name(.)='InclusiveNamespaces']\");\n\n    if (inclusiveNamespaces.length > 0) {\n      inclusiveNamespacesPrefixList = inclusiveNamespaces[0].getAttribute('PrefixList');\n    }\n  } //***workaround for validating windows mobile store signatures - it uses c14n but does not state it in the transforms\n\n\n  if (transforms.length == 1 && transforms[0] == \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\") transforms.push(\"http://www.w3.org/2001/10/xml-exc-c14n#\");\n  this.addReference(null, transforms, digestAlgo, utils.findAttr(ref, \"URI\").value, digestValue, inclusiveNamespacesPrefixList, false);\n};\n\nSignedXml.prototype.addReference = function (xpath, transforms, digestAlgorithm, uri, digestValue, inclusiveNamespacesPrefixList, isEmptyUri) {\n  this.references.push({\n    \"xpath\": xpath,\n    \"transforms\": transforms ? transforms : [\"http://www.w3.org/2001/10/xml-exc-c14n#\"],\n    \"digestAlgorithm\": digestAlgorithm ? digestAlgorithm : \"http://www.w3.org/2000/09/xmldsig#sha1\",\n    \"uri\": uri,\n    \"digestValue\": digestValue,\n    \"inclusiveNamespacesPrefixList\": inclusiveNamespacesPrefixList,\n    \"isEmptyUri\": isEmptyUri\n  });\n};\n/**\n * Compute the signature of the given xml (usign the already defined settings)\n *\n * Options:\n *\n * - `prefix` {String} Adds a prefix for the generated signature tags\n * - `attrs` {Object} A hash of attributes and values `attrName: value` to add to the signature root node\n * - `location` {{ reference: String, action: String }}\n *   An object with a `reference` key which should\n *   contain a XPath expression, an `action` key which\n *   should contain one of the following values:\n *   `append`, `prepend`, `before`, `after`\n *\n */\n\n\nSignedXml.prototype.computeSignature = function (xml, opts) {\n  var doc = new Dom().parseFromString(xml),\n      xmlNsAttr = \"xmlns\",\n      signatureAttrs = [],\n      location,\n      attrs,\n      prefix,\n      currentPrefix;\n  var validActions = [\"append\", \"prepend\", \"before\", \"after\"];\n  opts = opts || {};\n  prefix = opts.prefix;\n  attrs = opts.attrs || {};\n  location = opts.location || {}; // defaults to the root node\n\n  location.reference = location.reference || \"/*\"; // defaults to append action\n\n  location.action = location.action || \"append\";\n\n  if (validActions.indexOf(location.action) === -1) {\n    throw new Error(\"location.action option has an invalid action: \" + location.action + \", must be any of the following values: \" + validActions.join(\", \"));\n  } // automatic insertion of `:`\n\n\n  if (prefix) {\n    xmlNsAttr += \":\" + prefix;\n    currentPrefix = prefix + \":\";\n  } else {\n    currentPrefix = \"\";\n  }\n\n  Object.keys(attrs).forEach(function (name) {\n    if (name !== \"xmlns\" && name !== xmlNsAttr) {\n      signatureAttrs.push(name + \"=\\\"\" + attrs[name] + \"\\\"\");\n    }\n  }); // add the xml namespace attribute\n\n  signatureAttrs.push(xmlNsAttr + \"=\\\"http://www.w3.org/2000/09/xmldsig#\\\"\");\n  this.signatureXml = \"<\" + currentPrefix + \"Signature \" + signatureAttrs.join(\" \") + \">\";\n  var signedInfo = this.createSignedInfo(doc, prefix);\n  this.signatureXml += signedInfo;\n  this.signatureXml += this.createSignature(signedInfo, prefix);\n  this.signatureXml += this.getKeyInfo(prefix);\n  this.signatureXml += \"</\" + currentPrefix + \"Signature>\";\n  this.originalXmlWithIds = doc.toString();\n  var signatureDoc = new Dom().parseFromString(this.signatureXml);\n  var referenceNode = select(doc, location.reference);\n\n  if (!referenceNode || referenceNode.length === 0) {\n    throw new Error(\"the following xpath cannot be used because it was not found: \" + location.reference);\n  }\n\n  referenceNode = referenceNode[0];\n\n  if (location.action === \"append\") {\n    referenceNode.appendChild(signatureDoc.documentElement);\n  } else if (location.action === \"prepend\") {\n    referenceNode.insertBefore(signatureDoc.documentElement, referenceNode.firstChild);\n  } else if (location.action === \"before\") {\n    referenceNode.parentNode.insertBefore(signatureDoc.documentElement, referenceNode);\n  } else if (location.action === \"after\") {\n    referenceNode.parentNode.insertBefore(signatureDoc.documentElement, referenceNode.nextSibling);\n  }\n\n  this.signedXml = doc.toString();\n};\n\nSignedXml.prototype.getKeyInfo = function (prefix) {\n  var res = \"\";\n  var currentPrefix;\n  currentPrefix = prefix || '';\n  currentPrefix = currentPrefix ? currentPrefix + ':' : currentPrefix;\n\n  if (this.keyInfoProvider) {\n    res += \"<\" + currentPrefix + \"KeyInfo>\";\n    res += this.keyInfoProvider.getKeyInfo(this.signingKey, prefix);\n    res += \"</\" + currentPrefix + \"KeyInfo>\";\n  }\n\n  return res;\n};\n/**\n * Generate the Reference nodes (as part of the signature process)\n *\n */\n\n\nSignedXml.prototype.createReferences = function (doc, prefix) {\n  var res = \"\";\n  prefix = prefix || '';\n  prefix = prefix ? prefix + ':' : prefix;\n\n  for (var n in this.references) {\n    if (!this.references.hasOwnProperty(n)) continue;\n    var ref = this.references[n],\n        nodes = select(doc, ref.xpath);\n\n    if (nodes.length == 0) {\n      throw new Error('the following xpath cannot be signed because it was not found: ' + ref.xpath);\n    }\n\n    for (var h in nodes) {\n      if (!nodes.hasOwnProperty(h)) continue;\n      var node = nodes[h];\n\n      if (ref.isEmptyUri) {\n        res += \"<\" + prefix + \"Reference URI=\\\"\\\">\";\n      } else {\n        var id = this.ensureHasId(node);\n        ref.uri = id;\n        res += \"<\" + prefix + \"Reference URI=\\\"#\" + id + \"\\\">\";\n      }\n\n      res += \"<\" + prefix + \"Transforms>\";\n\n      for (var t in ref.transforms) {\n        if (!ref.transforms.hasOwnProperty(t)) continue;\n        var trans = ref.transforms[t];\n        var transform = this.findCanonicalizationAlgorithm(trans);\n        res += \"<\" + prefix + \"Transform Algorithm=\\\"\" + transform.getAlgorithmName() + \"\\\" />\";\n      }\n\n      var canonXml = this.getCanonXml(ref.transforms, node);\n      var digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);\n      res += \"</\" + prefix + \"Transforms>\" + \"<\" + prefix + \"DigestMethod Algorithm=\\\"\" + digestAlgorithm.getAlgorithmName() + \"\\\" />\" + \"<\" + prefix + \"DigestValue>\" + digestAlgorithm.getHash(canonXml) + \"</\" + prefix + \"DigestValue>\" + \"</\" + prefix + \"Reference>\";\n    }\n  }\n\n  return res;\n};\n\nSignedXml.prototype.getCanonXml = function (transforms, node, options) {\n  options = options || {};\n  options.defaultNsForPrefix = options.defaultNsForPrefix || SignedXml.defaultNsForPrefix;\n  var canonXml = node;\n\n  for (var t in transforms) {\n    if (!transforms.hasOwnProperty(t)) continue;\n    var transform = this.findCanonicalizationAlgorithm(transforms[t]);\n    canonXml = transform.process(canonXml, options); //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\n    //This eitehr needs to be more explicit in the API, or all should return the same.\n    //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would inccorectly minimize empty tags\n    //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\n    //enveloped transformation returns Node since if it would return String consider this case:\n    //<x xmlns:p='ns'><p:y/></x>\n    //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\n  }\n\n  return canonXml.toString();\n};\n/**\n * Ensure an element has Id attribute. If not create it with unique value.\n * Work with both normal and wssecurity Id flavour\n */\n\n\nSignedXml.prototype.ensureHasId = function (node) {\n  var attr;\n\n  if (this.idMode == \"wssecurity\") {\n    attr = utils.findAttr(node, \"Id\", \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\");\n  } else {\n    for (var index in this.idAttributes) {\n      if (!this.idAttributes.hasOwnProperty(index)) continue;\n      attr = utils.findAttr(node, this.idAttributes[index], null);\n      if (attr) break;\n    }\n  }\n\n  if (attr) return attr.value; //add the attribute\n\n  var id = \"_\" + this.id++;\n\n  if (this.idMode == \"wssecurity\") {\n    node.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:wsu\", \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\");\n    node.setAttributeNS(\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\", \"wsu:Id\", id);\n  } else {\n    node.setAttribute(\"Id\", id);\n  }\n\n  return id;\n};\n/**\n * Create the SignedInfo element\n *\n */\n\n\nSignedXml.prototype.createSignedInfo = function (doc, prefix) {\n  var transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\n  var algo = this.findSignatureAlgorithm(this.signatureAlgorithm);\n  var currentPrefix;\n  currentPrefix = prefix || '';\n  currentPrefix = currentPrefix ? currentPrefix + ':' : currentPrefix;\n  var res = \"<\" + currentPrefix + \"SignedInfo>\";\n  res += \"<\" + currentPrefix + \"CanonicalizationMethod Algorithm=\\\"\" + transform.getAlgorithmName() + \"\\\" />\" + \"<\" + currentPrefix + \"SignatureMethod Algorithm=\\\"\" + algo.getAlgorithmName() + \"\\\" />\";\n  res += this.createReferences(doc, prefix);\n  res += \"</\" + currentPrefix + \"SignedInfo>\";\n  return res;\n};\n/**\n * Create the Signature element\n *\n */\n\n\nSignedXml.prototype.createSignature = function (signedInfo, prefix) {\n  var xmlNsAttr = 'xmlns';\n\n  if (prefix) {\n    xmlNsAttr += ':' + prefix;\n    prefix += ':';\n  } else {\n    prefix = '';\n  } //the canonicalization requires to get a valid xml node.\n  //we need to wrap the info in a dummy signature since it contains the default namespace.\n\n\n  var dummySignatureWrapper = \"<\" + prefix + \"Signature \" + xmlNsAttr + \"=\\\"http://www.w3.org/2000/09/xmldsig#\\\">\" + signedInfo + \"</\" + prefix + \"Signature>\";\n  var xml = new Dom().parseFromString(dummySignatureWrapper); //get the signedInfo\n\n  var node = xml.documentElement.firstChild;\n  var canAlgorithm = new this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\n  var canonizedSignedInfo = canAlgorithm.process(node);\n  var signatureAlgorithm = this.findSignatureAlgorithm(this.signatureAlgorithm);\n  this.signatureValue = signatureAlgorithm.getSignature(canonizedSignedInfo, this.signingKey);\n  return \"<\" + prefix + \"SignatureValue>\" + this.signatureValue + \"</\" + prefix + \"SignatureValue>\";\n};\n\nSignedXml.prototype.getSignatureXml = function () {\n  return this.signatureXml;\n};\n\nSignedXml.prototype.getOriginalXmlWithIds = function () {\n  return this.originalXmlWithIds;\n};\n\nSignedXml.prototype.getSignedXml = function () {\n  return this.signedXml;\n};","map":null,"metadata":{},"sourceType":"script"}