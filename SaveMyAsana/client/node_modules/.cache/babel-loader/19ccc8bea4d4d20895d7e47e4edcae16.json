{"ast":null,"code":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n *\r\n */\n\n/*jshint proto:true*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/garnetdianthus/Repoman/Project3/SaveMyAsana/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar sax = require('sax');\n\nvar inherits = require('util').inherits;\n\nvar HttpClient = require('./http');\n\nvar NamespaceContext = require('./nscontext');\n\nvar fs = require('fs');\n\nvar url = require('url');\n\nvar path = require('path');\n\nvar assert = require('assert').ok;\n\nvar stripBom = require('strip-bom');\n\nvar debug = require('debug')('node-soap');\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar TNS_PREFIX = utils.TNS_PREFIX;\nvar findPrefix = utils.findPrefix;\nvar Primitives = {\n  string: 1,\n  boolean: 1,\n  decimal: 1,\n  float: 1,\n  double: 1,\n  anyType: 1,\n  byte: 1,\n  int: 1,\n  long: 1,\n  short: 1,\n  negativeInteger: 1,\n  nonNegativeInteger: 1,\n  positiveInteger: 1,\n  nonPositiveInteger: 1,\n  unsignedByte: 1,\n  unsignedInt: 1,\n  unsignedLong: 1,\n  unsignedShort: 1,\n  duration: 0,\n  dateTime: 0,\n  time: 0,\n  date: 0,\n  gYearMonth: 0,\n  gYear: 0,\n  gMonthDay: 0,\n  gDay: 0,\n  gMonth: 0,\n  hexBinary: 0,\n  base64Binary: 0,\n  anyURI: 0,\n  QName: 0,\n  NOTATION: 0\n};\n\nfunction splitQName(nsName) {\n  if (typeof nsName !== 'string') {\n    return {\n      prefix: TNS_PREFIX,\n      name: nsName\n    };\n  }\n\n  var _nsName$split = nsName.split('|'),\n      _nsName$split2 = _slicedToArray(_nsName$split, 1),\n      topLevelName = _nsName$split2[0];\n\n  var prefixOffset = topLevelName.indexOf(':');\n  return {\n    prefix: topLevelName.substring(0, prefixOffset) || TNS_PREFIX,\n    name: topLevelName.substring(prefixOffset + 1)\n  };\n}\n\nfunction xmlEscape(obj) {\n  if (typeof obj === 'string') {\n    if (obj.substr(0, 9) === '<![CDATA[' && obj.substr(-3) === \"]]>\") {\n      return obj;\n    }\n\n    return obj.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;');\n  }\n\n  return obj;\n}\n\nvar trimLeft = /^[\\s\\xA0]+/;\nvar trimRight = /[\\s\\xA0]+$/;\n\nfunction trim(text) {\n  return text.replace(trimLeft, '').replace(trimRight, '');\n}\n\nfunction deepMerge(destination, source) {\n  return _.mergeWith(destination || {}, source, function (a, b) {\n    return _.isArray(a) ? a.concat(b) : undefined;\n  });\n}\n\nvar Element = function Element(nsName, attrs, options, schemaAttrs) {\n  var parts = splitQName(nsName);\n  this.nsName = nsName;\n  this.prefix = parts.prefix;\n  this.name = parts.name;\n  this.children = [];\n  this.xmlns = {};\n  this.schemaXmlns = {};\n\n  this._initializeOptions(options);\n\n  for (var key in attrs) {\n    var match = /^xmlns:?(.*)$/.exec(key);\n\n    if (match) {\n      this.xmlns[match[1] ? match[1] : TNS_PREFIX] = attrs[key];\n    } else {\n      if (key === 'value') {\n        this[this.valueKey] = attrs[key];\n      } else {\n        this['$' + key] = attrs[key];\n      }\n    }\n  }\n\n  for (var schemaKey in schemaAttrs) {\n    var schemaMatch = /^xmlns:?(.*)$/.exec(schemaKey);\n\n    if (schemaMatch && schemaMatch[1]) {\n      this.schemaXmlns[schemaMatch[1]] = schemaAttrs[schemaKey];\n    }\n  }\n\n  if (this.$targetNamespace !== undefined) {\n    // Add targetNamespace to the mapping\n    this.xmlns[TNS_PREFIX] = this.$targetNamespace;\n  }\n};\n\nElement.prototype._initializeOptions = function (options) {\n  if (options) {\n    this.valueKey = options.valueKey || '$value';\n    this.xmlKey = options.xmlKey || '$xml';\n    this.ignoredNamespaces = options.ignoredNamespaces || [];\n  } else {\n    this.valueKey = '$value';\n    this.xmlKey = '$xml';\n    this.ignoredNamespaces = [];\n  }\n};\n\nElement.prototype.deleteFixedAttrs = function () {\n  this.children && this.children.length === 0 && delete this.children;\n  this.xmlns && Object.keys(this.xmlns).length === 0 && delete this.xmlns;\n  delete this.nsName;\n  delete this.prefix;\n  delete this.name;\n};\n\nElement.prototype.allowedChildren = [];\n\nElement.prototype.startElement = function (stack, nsName, attrs, options, schemaXmlns) {\n  if (!this.allowedChildren) {\n    return;\n  }\n\n  var ChildClass = this.allowedChildren[splitQName(nsName).name],\n      element = null;\n\n  if (ChildClass) {\n    stack.push(new ChildClass(nsName, attrs, options, schemaXmlns));\n  } else {\n    this.unexpected(nsName);\n  }\n};\n\nElement.prototype.endElement = function (stack, nsName) {\n  if (this.nsName === nsName) {\n    if (stack.length < 2) return;\n    var parent = stack[stack.length - 2];\n\n    if (this !== stack[0]) {\n      _.defaultsDeep(stack[0].xmlns, this.xmlns); // delete this.xmlns;\n\n\n      parent.children.push(this);\n      parent.addChild(this);\n    }\n\n    stack.pop();\n  }\n};\n\nElement.prototype.addChild = function (child) {\n  return;\n};\n\nElement.prototype.unexpected = function (name) {\n  throw new Error('Found unexpected element (' + name + ') inside ' + this.nsName);\n};\n\nElement.prototype.description = function (definitions) {\n  return this.$name || this.name;\n};\n\nElement.prototype.init = function () {};\n\nElement.createSubClass = function () {\n  var root = this;\n\n  var subElement = function subElement() {\n    root.apply(this, arguments);\n    this.init();\n  }; // inherits(subElement, root);\n\n\n  subElement.prototype.__proto__ = root.prototype;\n  return subElement;\n};\n\nvar ElementElement = Element.createSubClass();\nvar AnyElement = Element.createSubClass();\nvar InputElement = Element.createSubClass();\nvar OutputElement = Element.createSubClass();\nvar SimpleTypeElement = Element.createSubClass();\nvar RestrictionElement = Element.createSubClass();\nvar ExtensionElement = Element.createSubClass();\nvar ChoiceElement = Element.createSubClass();\nvar EnumerationElement = Element.createSubClass();\nvar ComplexTypeElement = Element.createSubClass();\nvar ComplexContentElement = Element.createSubClass();\nvar SimpleContentElement = Element.createSubClass();\nvar SequenceElement = Element.createSubClass();\nvar AllElement = Element.createSubClass();\nvar MessageElement = Element.createSubClass();\nvar DocumentationElement = Element.createSubClass();\nvar SchemaElement = Element.createSubClass();\nvar TypesElement = Element.createSubClass();\nvar OperationElement = Element.createSubClass();\nvar PortTypeElement = Element.createSubClass();\nvar BindingElement = Element.createSubClass();\nvar PortElement = Element.createSubClass();\nvar ServiceElement = Element.createSubClass();\nvar DefinitionsElement = Element.createSubClass();\nvar ElementTypeMap = {\n  types: [TypesElement, 'schema documentation'],\n  schema: [SchemaElement, 'element complexType simpleType include import'],\n  element: [ElementElement, 'annotation complexType simpleType'],\n  any: [AnyElement, ''],\n  simpleType: [SimpleTypeElement, 'restriction'],\n  restriction: [RestrictionElement, 'enumeration all choice sequence'],\n  extension: [ExtensionElement, 'all sequence choice'],\n  choice: [ChoiceElement, 'element sequence choice any'],\n  // group: [GroupElement, 'element group'],\n  enumeration: [EnumerationElement, ''],\n  complexType: [ComplexTypeElement, 'annotation sequence all complexContent simpleContent choice'],\n  complexContent: [ComplexContentElement, 'extension'],\n  simpleContent: [SimpleContentElement, 'extension'],\n  sequence: [SequenceElement, 'element sequence choice any'],\n  all: [AllElement, 'element choice'],\n  service: [ServiceElement, 'port documentation'],\n  port: [PortElement, 'address documentation'],\n  binding: [BindingElement, '_binding SecuritySpec operation documentation'],\n  portType: [PortTypeElement, 'operation documentation'],\n  message: [MessageElement, 'part documentation'],\n  operation: [OperationElement, 'documentation input output fault _operation'],\n  input: [InputElement, 'body SecuritySpecRef documentation header'],\n  output: [OutputElement, 'body SecuritySpecRef documentation header'],\n  fault: [Element, '_fault documentation'],\n  definitions: [DefinitionsElement, 'types message portType binding service import documentation'],\n  documentation: [DocumentationElement, '']\n};\n\nfunction mapElementTypes(types) {\n  var rtn = {};\n  types = types.split(' ');\n  types.forEach(function (type) {\n    rtn[type.replace(/^_/, '')] = (ElementTypeMap[type] || [Element])[0];\n  });\n  return rtn;\n}\n\nfor (var n in ElementTypeMap) {\n  var v = ElementTypeMap[n];\n  v[0].prototype.allowedChildren = mapElementTypes(v[1]);\n}\n\nMessageElement.prototype.init = function () {\n  this.element = null;\n  this.parts = null;\n};\n\nSchemaElement.prototype.init = function () {\n  this.complexTypes = {};\n  this.types = {};\n  this.elements = {};\n  this.includes = [];\n};\n\nTypesElement.prototype.init = function () {\n  this.schemas = {};\n};\n\nOperationElement.prototype.init = function () {\n  this.input = null;\n  this.output = null;\n  this.inputSoap = null;\n  this.outputSoap = null;\n  this.style = '';\n  this.soapAction = '';\n};\n\nPortTypeElement.prototype.init = function () {\n  this.methods = {};\n};\n\nBindingElement.prototype.init = function () {\n  this.transport = '';\n  this.style = '';\n  this.methods = {};\n};\n\nPortElement.prototype.init = function () {\n  this.location = null;\n};\n\nServiceElement.prototype.init = function () {\n  this.ports = {};\n};\n\nDefinitionsElement.prototype.init = function () {\n  if (this.name !== 'definitions') this.unexpected(this.nsName);\n  this.messages = {};\n  this.portTypes = {};\n  this.bindings = {};\n  this.services = {};\n  this.schemas = {};\n};\n\nDocumentationElement.prototype.init = function () {};\n\nSchemaElement.prototype.merge = function (source) {\n  assert(source instanceof SchemaElement);\n\n  if (this.$targetNamespace === source.$targetNamespace) {\n    _.merge(this.complexTypes, source.complexTypes);\n\n    _.merge(this.types, source.types);\n\n    _.merge(this.elements, source.elements);\n\n    _.merge(this.xmlns, source.xmlns);\n  }\n\n  return this;\n};\n\nSchemaElement.prototype.addChild = function (child) {\n  if (child.$name in Primitives) return;\n\n  if (child.name === 'include' || child.name === 'import') {\n    var location = child.$schemaLocation || child.$location;\n\n    if (location) {\n      this.includes.push({\n        namespace: child.$namespace || child.$targetNamespace || this.$targetNamespace,\n        location: location\n      });\n    }\n  } else if (child.name === 'complexType') {\n    this.complexTypes[child.$name] = child;\n  } else if (child.name === 'element') {\n    this.elements[child.$name] = child;\n  } else if (child.$name) {\n    this.types[child.$name] = child;\n  }\n\n  this.children.pop(); // child.deleteFixedAttrs();\n}; //fix#325\n\n\nTypesElement.prototype.addChild = function (child) {\n  assert(child instanceof SchemaElement);\n  var targetNamespace = child.$targetNamespace;\n\n  if (!this.schemas.hasOwnProperty(targetNamespace)) {\n    this.schemas[targetNamespace] = child;\n  } else {\n    console.error('Target-Namespace \"' + targetNamespace + '\" already in use by another Schema!');\n  }\n};\n\nInputElement.prototype.addChild = function (child) {\n  if (child.name === 'body') {\n    this.use = child.$use;\n\n    if (this.use === 'encoded') {\n      this.encodingStyle = child.$encodingStyle;\n    }\n\n    this.children.pop();\n  }\n};\n\nOutputElement.prototype.addChild = function (child) {\n  if (child.name === 'body') {\n    this.use = child.$use;\n\n    if (this.use === 'encoded') {\n      this.encodingStyle = child.$encodingStyle;\n    }\n\n    this.children.pop();\n  }\n};\n\nOperationElement.prototype.addChild = function (child) {\n  if (child.name === 'operation') {\n    this.soapAction = child.$soapAction || '';\n    this.style = child.$style || '';\n    this.children.pop();\n  }\n};\n\nBindingElement.prototype.addChild = function (child) {\n  if (child.name === 'binding') {\n    this.transport = child.$transport;\n    this.style = child.$style;\n    this.children.pop();\n  }\n};\n\nPortElement.prototype.addChild = function (child) {\n  if (child.name === 'address' && typeof child.$location !== 'undefined') {\n    this.location = child.$location;\n  }\n};\n\nDefinitionsElement.prototype.addChild = function (child) {\n  var self = this;\n\n  if (child instanceof TypesElement) {\n    // Merge types.schemas into definitions.schemas\n    _.merge(self.schemas, child.schemas);\n  } else if (child instanceof MessageElement) {\n    self.messages[child.$name] = child;\n  } else if (child.name === 'import') {\n    self.schemas[child.$namespace] = new SchemaElement(child.$namespace, {});\n    self.schemas[child.$namespace].addChild(child);\n  } else if (child instanceof PortTypeElement) {\n    self.portTypes[child.$name] = child;\n  } else if (child instanceof BindingElement) {\n    if (child.transport === 'http://schemas.xmlsoap.org/soap/http' || child.transport === 'http://www.w3.org/2003/05/soap/bindings/HTTP/') self.bindings[child.$name] = child;\n  } else if (child instanceof ServiceElement) {\n    self.services[child.$name] = child;\n  } else if (child instanceof DocumentationElement) {}\n\n  this.children.pop();\n};\n\nMessageElement.prototype.postProcess = function (definitions) {\n  var part = null;\n  var child;\n  var children = this.children || [];\n  var ns;\n  var nsName;\n  var i;\n  var type;\n\n  for (i in children) {\n    if ((child = children[i]).name === 'part') {\n      part = child;\n      break;\n    }\n  }\n\n  if (!part) {\n    return;\n  }\n\n  if (part.$element) {\n    var lookupTypes = [],\n        elementChildren;\n    delete this.parts;\n    nsName = splitQName(part.$element);\n    ns = nsName.prefix;\n    var schema = definitions.schemas[definitions.xmlns[ns]];\n    this.element = schema.elements[nsName.name];\n\n    if (!this.element) {\n      debug(nsName.name + \" is not present in wsdl and cannot be processed correctly.\");\n      return;\n    }\n\n    this.element.targetNSAlias = ns;\n    this.element.targetNamespace = definitions.xmlns[ns]; // set the optional $lookupType to be used within `client#_invoke()` when\n    // calling `wsdl#objectToDocumentXML()\n\n    this.element.$lookupType = part.$element;\n    elementChildren = this.element.children; // get all nested lookup types (only complex types are followed)\n\n    if (elementChildren.length > 0) {\n      for (i = 0; i < elementChildren.length; i++) {\n        lookupTypes.push(this._getNestedLookupTypeString(elementChildren[i]));\n      }\n    } // if nested lookup types where found, prepare them for furter usage\n\n\n    if (lookupTypes.length > 0) {\n      lookupTypes = lookupTypes.join('_').split('_').filter(function removeEmptyLookupTypes(type) {\n        return type !== '^';\n      });\n      var schemaXmlns = definitions.schemas[this.element.targetNamespace].xmlns;\n\n      for (i = 0; i < lookupTypes.length; i++) {\n        lookupTypes[i] = this._createLookupTypeObject(lookupTypes[i], schemaXmlns);\n      }\n    }\n\n    this.element.$lookupTypes = lookupTypes;\n\n    if (this.element.$type) {\n      type = splitQName(this.element.$type);\n      var typeNs = schema.xmlns && schema.xmlns[type.prefix] || definitions.xmlns[type.prefix];\n\n      if (typeNs) {\n        if (type.name in Primitives) {// this.element = this.element.$type;\n        } else {\n          // first check local mapping of ns alias to namespace\n          schema = definitions.schemas[typeNs];\n          var ctype = schema.complexTypes[type.name] || schema.types[type.name] || schema.elements[type.name];\n\n          if (ctype) {\n            this.parts = ctype.description(definitions, schema.xmlns);\n          }\n        }\n      }\n    } else {\n      var method = this.element.description(definitions, schema.xmlns);\n      this.parts = method[nsName.name];\n    }\n\n    this.children.splice(0, 1);\n  } else {\n    // rpc encoding\n    this.parts = {};\n    delete this.element;\n\n    for (i = 0; part = this.children[i]; i++) {\n      if (part.name === 'documentation') {\n        // <wsdl:documentation can be present under <wsdl:message>\n        continue;\n      }\n\n      assert(part.name === 'part', 'Expected part element');\n      nsName = splitQName(part.$type);\n      ns = definitions.xmlns[nsName.prefix];\n      type = nsName.name;\n      var schemaDefinition = definitions.schemas[ns];\n\n      if (typeof schemaDefinition !== 'undefined') {\n        this.parts[part.$name] = definitions.schemas[ns].types[type] || definitions.schemas[ns].complexTypes[type];\n      } else {\n        this.parts[part.$name] = part.$type;\n      }\n\n      if (typeof this.parts[part.$name] === 'object') {\n        this.parts[part.$name].prefix = nsName.prefix;\n        this.parts[part.$name].xmlns = ns;\n      }\n\n      this.children.splice(i--, 1);\n    }\n  }\n\n  this.deleteFixedAttrs();\n};\n/**\r\n * Takes a given namespaced String(for example: 'alias:property') and creates a lookupType\r\n * object for further use in as first (lookup) `parameterTypeObj` within the `objectToXML`\r\n * method and provides an entry point for the already existing code in `findChildSchemaObject`.\r\n *\r\n * @method _createLookupTypeObject\r\n * @param {String}            nsString          The NS String (for example \"alias:type\").\r\n * @param {Object}            xmlns       The fully parsed `wsdl` definitions object (including all schemas).\r\n * @returns {Object}\r\n * @private\r\n */\n\n\nMessageElement.prototype._createLookupTypeObject = function (nsString, xmlns) {\n  var splittedNSString = splitQName(nsString),\n      nsAlias = splittedNSString.prefix,\n      splittedName = splittedNSString.name.split('#'),\n      type = splittedName[0],\n      name = splittedName[1],\n      lookupTypeObj = {};\n  lookupTypeObj.$namespace = xmlns[nsAlias];\n  lookupTypeObj.$type = nsAlias + ':' + type;\n  lookupTypeObj.$name = name;\n  return lookupTypeObj;\n};\n/**\r\n * Iterates through the element and every nested child to find any defined `$type`\r\n * property and returns it in a underscore ('_') separated String (using '^' as default\r\n * value if no `$type` property was found).\r\n *\r\n * @method _getNestedLookupTypeString\r\n * @param {Object}            element         The element which (probably) contains nested `$type` values.\r\n * @returns {String}\r\n * @private\r\n */\n\n\nMessageElement.prototype._getNestedLookupTypeString = function (element) {\n  var resolvedType = '^',\n      excluded = this.ignoredNamespaces.concat('xs'); // do not process $type values wich start with\n\n  if (element.hasOwnProperty('$type') && typeof element.$type === 'string') {\n    if (excluded.indexOf(element.$type.split(':')[0]) === -1) {\n      resolvedType += '_' + element.$type + '#' + element.$name;\n    }\n  }\n\n  if (element.children.length > 0) {\n    var self = this;\n    element.children.forEach(function (child) {\n      var resolvedChildType = self._getNestedLookupTypeString(child).replace(/\\^_/, '');\n\n      if (resolvedChildType && typeof resolvedChildType === 'string') {\n        resolvedType += '_' + resolvedChildType;\n      }\n    });\n  }\n\n  return resolvedType;\n};\n\nOperationElement.prototype.postProcess = function (definitions, tag) {\n  var children = this.children;\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child.name !== 'input' && child.name !== 'output') continue;\n\n    if (tag === 'binding') {\n      this[child.name] = child;\n      children.splice(i--, 1);\n      continue;\n    }\n\n    var messageName = splitQName(child.$message).name;\n    var message = definitions.messages[messageName];\n    message.postProcess(definitions);\n\n    if (message.element) {\n      definitions.messages[message.element.$name] = message;\n      this[child.name] = message.element;\n    } else {\n      this[child.name] = message;\n    }\n\n    children.splice(i--, 1);\n  }\n\n  this.deleteFixedAttrs();\n};\n\nPortTypeElement.prototype.postProcess = function (definitions) {\n  var children = this.children;\n  if (typeof children === 'undefined') return;\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child.name !== 'operation') continue;\n    child.postProcess(definitions, 'portType');\n    this.methods[child.$name] = child;\n    children.splice(i--, 1);\n  }\n\n  delete this.$name;\n  this.deleteFixedAttrs();\n};\n\nBindingElement.prototype.postProcess = function (definitions) {\n  var type = splitQName(this.$type).name,\n      portType = definitions.portTypes[type],\n      style = this.style,\n      children = this.children;\n\n  if (portType) {\n    portType.postProcess(definitions);\n    this.methods = portType.methods;\n\n    for (var i = 0, child; child = children[i]; i++) {\n      if (child.name !== 'operation') continue;\n      child.postProcess(definitions, 'binding');\n      children.splice(i--, 1);\n      child.style || (child.style = style);\n      var method = this.methods[child.$name];\n\n      if (method) {\n        method.style = child.style;\n        method.soapAction = child.soapAction;\n        method.inputSoap = child.input || null;\n        method.outputSoap = child.output || null;\n        method.inputSoap && method.inputSoap.deleteFixedAttrs();\n        method.outputSoap && method.outputSoap.deleteFixedAttrs();\n      }\n    }\n  }\n\n  delete this.$name;\n  delete this.$type;\n  this.deleteFixedAttrs();\n};\n\nServiceElement.prototype.postProcess = function (definitions) {\n  var children = this.children,\n      bindings = definitions.bindings;\n\n  if (children && children.length > 0) {\n    for (var i = 0, child; child = children[i]; i++) {\n      if (child.name !== 'port') continue;\n      var bindingName = splitQName(child.$binding).name;\n      var binding = bindings[bindingName];\n\n      if (binding) {\n        binding.postProcess(definitions);\n        this.ports[child.$name] = {\n          location: child.location,\n          binding: binding\n        };\n        children.splice(i--, 1);\n      }\n    }\n  }\n\n  delete this.$name;\n  this.deleteFixedAttrs();\n};\n\nSimpleTypeElement.prototype.description = function (definitions) {\n  var children = this.children;\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child instanceof RestrictionElement) return [this.$name, child.description()].filter(Boolean).join('|');\n  }\n\n  return {};\n};\n\nRestrictionElement.prototype.description = function (definitions, xmlns) {\n  var children = this.children;\n  var desc;\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child instanceof SequenceElement || child instanceof ChoiceElement) {\n      desc = child.description(definitions, xmlns);\n      break;\n    }\n  }\n\n  if (desc && this.$base) {\n    var type = splitQName(this.$base),\n        typeName = type.name,\n        ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\n        schema = definitions.schemas[ns],\n        typeElement = schema && (schema.complexTypes[typeName] || schema.types[typeName] || schema.elements[typeName]);\n\n    desc.getBase = function () {\n      return typeElement.description(definitions, schema.xmlns);\n    };\n\n    return desc;\n  } // then simple element\n\n\n  var base = this.$base ? this.$base + \"|\" : \"\";\n  var restrictions = this.children.map(function (child) {\n    return child.description();\n  }).join(\",\");\n  return [this.$base, restrictions].filter(Boolean).join('|');\n};\n\nExtensionElement.prototype.description = function (definitions, xmlns) {\n  var children = this.children;\n  var desc = {};\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child instanceof SequenceElement || child instanceof ChoiceElement) {\n      desc = child.description(definitions, xmlns);\n    }\n  }\n\n  if (this.$base) {\n    var type = splitQName(this.$base),\n        typeName = type.name,\n        ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\n        schema = definitions.schemas[ns];\n\n    if (typeName in Primitives) {\n      return this.$base;\n    } else {\n      var typeElement = schema && (schema.complexTypes[typeName] || schema.types[typeName] || schema.elements[typeName]);\n\n      if (typeElement) {\n        var base = typeElement.description(definitions, schema.xmlns);\n        desc = _.defaultsDeep(base, desc);\n      }\n    }\n  }\n\n  return desc;\n};\n\nEnumerationElement.prototype.description = function () {\n  return this[this.valueKey];\n};\n\nComplexTypeElement.prototype.description = function (definitions, xmlns) {\n  var children = this.children || [];\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child instanceof ChoiceElement || child instanceof SequenceElement || child instanceof AllElement || child instanceof SimpleContentElement || child instanceof ComplexContentElement) {\n      return child.description(definitions, xmlns);\n    }\n  }\n\n  return {};\n};\n\nComplexContentElement.prototype.description = function (definitions, xmlns) {\n  var children = this.children;\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child instanceof ExtensionElement) {\n      return child.description(definitions, xmlns);\n    }\n  }\n\n  return {};\n};\n\nSimpleContentElement.prototype.description = function (definitions, xmlns) {\n  var children = this.children;\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child instanceof ExtensionElement) {\n      return child.description(definitions, xmlns);\n    }\n  }\n\n  return {};\n};\n\nElementElement.prototype.description = function (definitions, xmlns) {\n  var element = {},\n      name = this.$name;\n  var isMany = !this.$maxOccurs ? false : isNaN(this.$maxOccurs) ? this.$maxOccurs === 'unbounded' : this.$maxOccurs > 1;\n\n  if (this.$minOccurs !== this.$maxOccurs && isMany) {\n    name += '[]';\n  }\n\n  if (xmlns && xmlns[TNS_PREFIX]) {\n    this.$targetNamespace = xmlns[TNS_PREFIX];\n  }\n\n  var type = this.$type || this.$ref;\n\n  if (type) {\n    type = splitQName(type);\n    var typeName = type.name,\n        ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix] !== undefined && this.schemaXmlns[type.prefix] || definitions.xmlns[type.prefix],\n        schema = definitions.schemas[ns],\n        typeElement = schema && (this.$type ? schema.complexTypes[typeName] || schema.types[typeName] : schema.elements[typeName]);\n\n    if (ns && definitions.schemas[ns]) {\n      xmlns = definitions.schemas[ns].xmlns;\n    }\n\n    if (typeElement && !(typeName in Primitives)) {\n      if (!(typeName in definitions.descriptions.types)) {\n        var elem = {};\n        definitions.descriptions.types[typeName] = elem;\n        var description = typeElement.description(definitions, xmlns);\n\n        if (typeof description === 'string') {\n          elem = description;\n        } else {\n          Object.keys(description).forEach(function (key) {\n            elem[key] = description[key];\n          });\n        }\n\n        if (this.$ref) {\n          element = elem;\n        } else {\n          element[name] = elem;\n        }\n\n        if (typeof elem === 'object') {\n          elem.targetNSAlias = type.prefix;\n          elem.targetNamespace = ns;\n        }\n\n        definitions.descriptions.types[typeName] = elem;\n      } else {\n        if (this.$ref) {\n          element = definitions.descriptions.types[typeName];\n        } else {\n          element[name] = definitions.descriptions.types[typeName];\n        }\n      }\n    } else {\n      element[name] = this.$type;\n    }\n  } else {\n    var children = this.children;\n    element[name] = {};\n\n    for (var i = 0, child; child = children[i]; i++) {\n      if (child instanceof ComplexTypeElement || child instanceof SimpleTypeElement) {\n        element[name] = child.description(definitions, xmlns);\n      }\n    }\n  }\n\n  return element;\n};\n\nAllElement.prototype.description = SequenceElement.prototype.description = function (definitions, xmlns) {\n  var children = this.children;\n  var sequence = {};\n\n  for (var i = 0, child; child = children[i]; i++) {\n    if (child instanceof AnyElement) {\n      continue;\n    }\n\n    var description = child.description(definitions, xmlns);\n\n    for (var key in description) {\n      sequence[key] = description[key];\n    }\n  }\n\n  return sequence;\n};\n\nChoiceElement.prototype.description = function (definitions, xmlns) {\n  var children = this.children;\n  var choice = {};\n\n  for (var i = 0, child; child = children[i]; i++) {\n    var description = child.description(definitions, xmlns);\n\n    for (var key in description) {\n      choice[key] = description[key];\n    }\n  }\n\n  return choice;\n};\n\nMessageElement.prototype.description = function (definitions) {\n  if (this.element) {\n    return this.element && this.element.description(definitions);\n  }\n\n  var desc = {};\n  desc[this.$name] = this.parts;\n  return desc;\n};\n\nPortTypeElement.prototype.description = function (definitions) {\n  var methods = {};\n\n  for (var name in this.methods) {\n    var method = this.methods[name];\n    methods[name] = method.description(definitions);\n  }\n\n  return methods;\n};\n\nOperationElement.prototype.description = function (definitions) {\n  var inputDesc = this.input ? this.input.description(definitions) : null;\n  var outputDesc = this.output ? this.output.description(definitions) : null;\n  return {\n    input: inputDesc && inputDesc[Object.keys(inputDesc)[0]],\n    output: outputDesc && outputDesc[Object.keys(outputDesc)[0]]\n  };\n};\n\nBindingElement.prototype.description = function (definitions) {\n  var methods = {};\n\n  for (var name in this.methods) {\n    var method = this.methods[name];\n    methods[name] = method.description(definitions);\n  }\n\n  return methods;\n};\n\nServiceElement.prototype.description = function (definitions) {\n  var ports = {};\n\n  for (var name in this.ports) {\n    var port = this.ports[name];\n    ports[name] = port.binding.description(definitions);\n  }\n\n  return ports;\n};\n\nvar WSDL = function WSDL(definition, uri, options) {\n  var self = this,\n      fromFunc;\n  this.uri = uri;\n\n  this.callback = function () {};\n\n  this._includesWsdl = []; // initialize WSDL cache\n\n  this.WSDL_CACHE = (options || {}).WSDL_CACHE || {};\n\n  this._initializeOptions(options);\n\n  if (typeof definition === 'string') {\n    definition = stripBom(definition);\n    fromFunc = this._fromXML;\n  } else if (typeof definition === 'object') {\n    fromFunc = this._fromServices;\n  } else {\n    throw new Error('WSDL constructor takes either an XML string or service definition');\n  }\n\n  process.nextTick(function () {\n    try {\n      fromFunc.call(self, definition);\n    } catch (e) {\n      return self.callback(e.message);\n    }\n\n    self.processIncludes(function (err) {\n      var name;\n\n      if (err) {\n        return self.callback(err);\n      }\n\n      self.definitions.deleteFixedAttrs();\n      var services = self.services = self.definitions.services;\n\n      if (services) {\n        for (name in services) {\n          services[name].postProcess(self.definitions);\n        }\n      }\n\n      var complexTypes = self.definitions.complexTypes;\n\n      if (complexTypes) {\n        for (name in complexTypes) {\n          complexTypes[name].deleteFixedAttrs();\n        }\n      } // for document style, for every binding, prepare input message element name to (methodName, output message element name) mapping\n\n\n      var bindings = self.definitions.bindings;\n\n      for (var bindingName in bindings) {\n        var binding = bindings[bindingName];\n\n        if (typeof binding.style === 'undefined') {\n          binding.style = 'document';\n        }\n\n        if (binding.style !== 'document') continue;\n        var methods = binding.methods;\n        var topEls = binding.topElements = {};\n\n        for (var methodName in methods) {\n          if (methods[methodName].input) {\n            var inputName = methods[methodName].input.$name;\n            var outputName = \"\";\n            if (methods[methodName].output) outputName = methods[methodName].output.$name;\n            topEls[inputName] = {\n              \"methodName\": methodName,\n              \"outputName\": outputName\n            };\n          }\n        }\n      } // prepare soap envelope xmlns definition string\n\n\n      self.xmlnsInEnvelope = self._xmlnsMap();\n      self.callback(err, self);\n    });\n  });\n};\n\nWSDL.prototype.ignoredNamespaces = ['tns', 'targetNamespace', 'typedNamespace'];\nWSDL.prototype.ignoreBaseNameSpaces = false;\nWSDL.prototype.valueKey = '$value';\nWSDL.prototype.xmlKey = '$xml';\n\nWSDL.prototype._initializeOptions = function (options) {\n  this._originalIgnoredNamespaces = (options || {}).ignoredNamespaces;\n  this.options = {};\n  var ignoredNamespaces = options ? options.ignoredNamespaces : null;\n\n  if (ignoredNamespaces && (Array.isArray(ignoredNamespaces.namespaces) || typeof ignoredNamespaces.namespaces === 'string')) {\n    if (ignoredNamespaces.override) {\n      this.options.ignoredNamespaces = ignoredNamespaces.namespaces;\n    } else {\n      this.options.ignoredNamespaces = this.ignoredNamespaces.concat(ignoredNamespaces.namespaces);\n    }\n  } else {\n    this.options.ignoredNamespaces = this.ignoredNamespaces;\n  }\n\n  this.options.valueKey = options.valueKey || this.valueKey;\n  this.options.xmlKey = options.xmlKey || this.xmlKey;\n\n  if (options.escapeXML !== undefined) {\n    this.options.escapeXML = options.escapeXML;\n  } else {\n    this.options.escapeXML = true;\n  }\n\n  if (options.returnFault !== undefined) {\n    this.options.returnFault = options.returnFault;\n  } else {\n    this.options.returnFault = false;\n  }\n\n  this.options.handleNilAsNull = !!options.handleNilAsNull;\n\n  if (options.namespaceArrayElements !== undefined) {\n    this.options.namespaceArrayElements = options.namespaceArrayElements;\n  } else {\n    this.options.namespaceArrayElements = true;\n  } // Allow any request headers to keep passing through\n\n\n  this.options.wsdl_headers = options.wsdl_headers;\n  this.options.wsdl_options = options.wsdl_options;\n\n  if (options.httpClient) {\n    this.options.httpClient = options.httpClient;\n  } // The supplied request-object should be passed through\n\n\n  if (options.request) {\n    this.options.request = options.request;\n  }\n\n  var ignoreBaseNameSpaces = options ? options.ignoreBaseNameSpaces : null;\n\n  if (ignoreBaseNameSpaces !== null && typeof ignoreBaseNameSpaces !== 'undefined') {\n    this.options.ignoreBaseNameSpaces = ignoreBaseNameSpaces;\n  } else {\n    this.options.ignoreBaseNameSpaces = this.ignoreBaseNameSpaces;\n  } // Works only in client\n\n\n  this.options.forceSoap12Headers = options.forceSoap12Headers;\n  this.options.customDeserializer = options.customDeserializer;\n\n  if (options.overrideRootElement !== undefined) {\n    this.options.overrideRootElement = options.overrideRootElement;\n  }\n\n  this.options.useEmptyTag = !!options.useEmptyTag;\n};\n\nWSDL.prototype.onReady = function (callback) {\n  if (callback) this.callback = callback;\n};\n\nWSDL.prototype._processNextInclude = function (includes, callback) {\n  var self = this,\n      include = includes.shift(),\n      options;\n  if (!include) return callback();\n  var includePath;\n\n  if (!/^https?:/.test(self.uri) && !/^https?:/.test(include.location)) {\n    includePath = path.resolve(path.dirname(self.uri), include.location);\n  } else {\n    includePath = url.resolve(self.uri || '', include.location);\n  }\n\n  options = _.assign({}, this.options); // follow supplied ignoredNamespaces option\n\n  options.ignoredNamespaces = this._originalIgnoredNamespaces || this.options.ignoredNamespaces;\n  options.WSDL_CACHE = this.WSDL_CACHE;\n  open_wsdl_recursive(includePath, options, function (err, wsdl) {\n    if (err) {\n      return callback(err);\n    }\n\n    self._includesWsdl.push(wsdl);\n\n    if (wsdl.definitions instanceof DefinitionsElement) {\n      _.mergeWith(self.definitions, wsdl.definitions, function (a, b) {\n        return a instanceof SchemaElement ? a.merge(b) : undefined;\n      });\n    } else {\n      self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace] = deepMerge(self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace], wsdl.definitions);\n    }\n\n    self._processNextInclude(includes, function (err) {\n      callback(err);\n    });\n  });\n};\n\nWSDL.prototype.processIncludes = function (callback) {\n  var schemas = this.definitions.schemas,\n      includes = [];\n\n  for (var ns in schemas) {\n    var schema = schemas[ns];\n    includes = includes.concat(schema.includes || []);\n  }\n\n  this._processNextInclude(includes, callback);\n};\n\nWSDL.prototype.describeServices = function () {\n  var services = {};\n\n  for (var name in this.services) {\n    var service = this.services[name];\n    services[name] = service.description(this.definitions);\n  }\n\n  return services;\n};\n\nWSDL.prototype.toXML = function () {\n  return this.xml || '';\n};\n\nWSDL.prototype.xmlToObject = function (xml, callback) {\n  var self = this;\n  var p = typeof callback === 'function' ? {} : sax.parser(true);\n  var objectName = null;\n  var root = {};\n  var schema = {\n    Envelope: {\n      Header: {\n        Security: {\n          UsernameToken: {\n            Username: 'string',\n            Password: 'string'\n          }\n        }\n      },\n      Body: {\n        Fault: {\n          faultcode: 'string',\n          faultstring: 'string',\n          detail: 'string'\n        }\n      }\n    }\n  };\n  var stack = [{\n    name: null,\n    object: root,\n    schema: schema\n  }];\n  var xmlns = {};\n  var refs = {},\n      id; // {id:{hrefs:[],obj:}, ...}\n\n  p.onopentag = function (node) {\n    var nsName = node.name;\n    var attrs = node.attributes;\n    var name = splitQName(nsName).name,\n        attributeName,\n        top = stack[stack.length - 1],\n        topSchema = top.schema,\n        elementAttributes = {},\n        hasNonXmlnsAttribute = false,\n        hasNilAttribute = false,\n        obj = {};\n    var originalName = name;\n\n    if (!objectName && top.name === 'Body' && name !== 'Fault') {\n      var message = self.definitions.messages[name]; // Support RPC/literal messages where response body contains one element named\n      // after the operation + 'Response'. See http://www.w3.org/TR/wsdl#_names\n\n      if (!message) {\n        try {\n          // Determine if this is request or response\n          var isInput = false;\n          var isOutput = false;\n\n          if (/Response$/.test(name)) {\n            isOutput = true;\n            name = name.replace(/Response$/, '');\n          } else if (/Request$/.test(name)) {\n            isInput = true;\n            name = name.replace(/Request$/, '');\n          } else if (/Solicit$/.test(name)) {\n            isInput = true;\n            name = name.replace(/Solicit$/, '');\n          } // Look up the appropriate message as given in the portType's operations\n\n\n          var portTypes = self.definitions.portTypes;\n          var portTypeNames = Object.keys(portTypes); // Currently this supports only one portType definition.\n\n          var portType = portTypes[portTypeNames[0]];\n\n          if (isInput) {\n            name = portType.methods[name].input.$name;\n          } else {\n            name = portType.methods[name].output.$name;\n          }\n\n          message = self.definitions.messages[name]; // 'cache' this alias to speed future lookups\n\n          self.definitions.messages[originalName] = self.definitions.messages[name];\n        } catch (e) {\n          if (self.options.returnFault) {\n            p.onerror(e);\n          }\n        }\n      }\n\n      topSchema = message.description(self.definitions);\n      objectName = originalName;\n    }\n\n    if (attrs.href) {\n      id = attrs.href.substr(1);\n\n      if (!refs[id]) {\n        refs[id] = {\n          hrefs: [],\n          obj: null\n        };\n      }\n\n      refs[id].hrefs.push({\n        par: top.object,\n        key: name,\n        obj: obj\n      });\n    }\n\n    if (id = attrs.id) {\n      if (!refs[id]) {\n        refs[id] = {\n          hrefs: [],\n          obj: null\n        };\n      }\n    } //Handle element attributes\n\n\n    for (attributeName in attrs) {\n      if (/^xmlns:|^xmlns$/.test(attributeName)) {\n        xmlns[splitQName(attributeName).name] = attrs[attributeName];\n        continue;\n      }\n\n      hasNonXmlnsAttribute = true;\n      elementAttributes[attributeName] = attrs[attributeName];\n    }\n\n    for (attributeName in elementAttributes) {\n      var res = splitQName(attributeName);\n\n      if (res.name === 'nil' && xmlns[res.prefix] === 'http://www.w3.org/2001/XMLSchema-instance' && elementAttributes[attributeName] && (elementAttributes[attributeName].toLowerCase() === 'true' || elementAttributes[attributeName] === '1')) {\n        hasNilAttribute = true;\n        break;\n      }\n    }\n\n    if (hasNonXmlnsAttribute) {\n      obj[self.options.attributesKey] = elementAttributes;\n    } // Pick up the schema for the type specified in element's xsi:type attribute.\n\n\n    var xsiTypeSchema;\n    var xsiType = elementAttributes['xsi:type'];\n\n    if (xsiType) {\n      var type = splitQName(xsiType);\n      var typeURI;\n\n      if (type.prefix === TNS_PREFIX) {\n        // In case of xsi:type = \"MyType\"\n        typeURI = xmlns[type.prefix] || xmlns.xmlns;\n      } else {\n        typeURI = xmlns[type.prefix];\n      }\n\n      var typeDef = self.findSchemaObject(typeURI, type.name);\n\n      if (typeDef) {\n        xsiTypeSchema = typeDef.description(self.definitions);\n      }\n    }\n\n    if (topSchema && topSchema[name + '[]']) {\n      name = name + '[]';\n    }\n\n    stack.push({\n      name: originalName,\n      object: obj,\n      schema: xsiTypeSchema || topSchema && topSchema[name],\n      id: attrs.id,\n      nil: hasNilAttribute\n    });\n  };\n\n  p.onclosetag = function (nsName) {\n    var cur = stack.pop(),\n        obj = cur.object,\n        top = stack[stack.length - 1],\n        topObject = top.object,\n        topSchema = top.schema,\n        name = splitQName(nsName).name;\n\n    if (typeof cur.schema === 'string' && (cur.schema === 'string' || cur.schema.split(':')[1] === 'string')) {\n      if (typeof obj === 'object' && Object.keys(obj).length === 0) obj = cur.object = '';\n    }\n\n    if (cur.nil === true) {\n      if (self.options.handleNilAsNull) {\n        obj = null;\n      } else {\n        return;\n      }\n    }\n\n    if (_.isPlainObject(obj) && !Object.keys(obj).length) {\n      obj = null;\n    }\n\n    if (topSchema && topSchema[name + '[]']) {\n      if (!topObject[name]) {\n        topObject[name] = [];\n      }\n\n      topObject[name].push(obj);\n    } else if (name in topObject) {\n      if (!Array.isArray(topObject[name])) {\n        topObject[name] = [topObject[name]];\n      }\n\n      topObject[name].push(obj);\n    } else {\n      topObject[name] = obj;\n    }\n\n    if (cur.id) {\n      refs[cur.id].obj = obj;\n    }\n  };\n\n  p.oncdata = function (text) {\n    var originalText = text;\n    text = trim(text);\n\n    if (!text.length) {\n      return;\n    }\n\n    if (/<\\?xml[\\s\\S]+\\?>/.test(text)) {\n      var top = stack[stack.length - 1];\n      var value = self.xmlToObject(text);\n\n      if (top.object[self.options.attributesKey]) {\n        top.object[self.options.valueKey] = value;\n      } else {\n        top.object = value;\n      }\n    } else {\n      p.ontext(originalText);\n    }\n  };\n\n  p.onerror = function (e) {\n    p.resume();\n    throw {\n      Fault: {\n        faultcode: 500,\n        faultstring: 'Invalid XML',\n        detail: new Error(e).message,\n        statusCode: 500\n      }\n    };\n  };\n\n  p.ontext = function (text) {\n    var originalText = text;\n    text = trim(text);\n\n    if (!text.length) {\n      return;\n    }\n\n    var top = stack[stack.length - 1];\n    var name = splitQName(top.schema).name,\n        value;\n\n    if (self.options && self.options.customDeserializer && self.options.customDeserializer[name]) {\n      value = self.options.customDeserializer[name](text, top);\n    } else {\n      if (name === 'int' || name === 'integer') {\n        value = parseInt(text, 10);\n      } else if (name === 'bool' || name === 'boolean') {\n        value = text.toLowerCase() === 'true' || text === '1';\n      } else if (name === 'dateTime' || name === 'date') {\n        value = new Date(text);\n      } else {\n        if (self.options.preserveWhitespace) {\n          text = originalText;\n        } // handle string or other types\n\n\n        if (typeof top.object !== 'string') {\n          value = text;\n        } else {\n          value = top.object + text;\n        }\n      }\n    }\n\n    if (top.object[self.options.attributesKey]) {\n      top.object[self.options.valueKey] = value;\n    } else {\n      top.object = value;\n    }\n  };\n\n  if (typeof callback === 'function') {\n    // we be streaming\n    var saxStream = sax.createStream(true);\n    saxStream.on('opentag', p.onopentag);\n    saxStream.on('closetag', p.onclosetag);\n    saxStream.on('cdata', p.oncdata);\n    saxStream.on('text', p.ontext);\n    xml.pipe(saxStream).on('error', function (err) {\n      callback(err);\n    }).on('end', function () {\n      var r;\n\n      try {\n        r = finish();\n      } catch (e) {\n        return callback(e);\n      }\n\n      callback(null, r);\n    });\n    return;\n  }\n\n  p.write(xml).close();\n  return finish();\n\n  function finish() {\n    // MultiRef support: merge objects instead of replacing\n    for (var n in refs) {\n      var ref = refs[n];\n\n      for (var i = 0; i < ref.hrefs.length; i++) {\n        _.assign(ref.hrefs[i].obj, ref.obj);\n      }\n    }\n\n    if (root.Envelope) {\n      var body = root.Envelope.Body;\n\n      if (body && body.Fault) {\n        var code = body.Fault.faultcode && body.Fault.faultcode.$value;\n        var string = body.Fault.faultstring && body.Fault.faultstring.$value;\n        var detail = body.Fault.detail && body.Fault.detail.$value;\n        code = code || body.Fault.faultcode;\n        string = string || body.Fault.faultstring;\n        detail = detail || body.Fault.detail;\n        var error = new Error(code + ': ' + string + (detail ? ': ' + detail : ''));\n        error.root = root;\n        throw error;\n      }\n\n      return root.Envelope;\n    }\n\n    return root;\n  }\n};\n/**\r\n * Look up a XSD type or element by namespace URI and name\r\n * @param {String} nsURI Namespace URI\r\n * @param {String} qname Local or qualified name\r\n * @returns {*} The XSD type/element definition\r\n */\n\n\nWSDL.prototype.findSchemaObject = function (nsURI, qname) {\n  if (!nsURI || !qname) {\n    return null;\n  }\n\n  var def = null;\n\n  if (this.definitions.schemas) {\n    var schema = this.definitions.schemas[nsURI];\n\n    if (schema) {\n      if (qname.indexOf(':') !== -1) {\n        qname = qname.substring(qname.indexOf(':') + 1, qname.length);\n      } // if the client passed an input element which has a `$lookupType` property instead of `$type`\n      // the `def` is found in `schema.elements`.\n\n\n      def = schema.complexTypes[qname] || schema.types[qname] || schema.elements[qname];\n    }\n  }\n\n  return def;\n};\n/**\r\n * Create document style xml string from the parameters\r\n * @param {String} name\r\n * @param {*} params\r\n * @param {String} nsPrefix\r\n * @param {String} nsURI\r\n * @param {String} type\r\n */\n\n\nWSDL.prototype.objectToDocumentXML = function (name, params, nsPrefix, nsURI, type) {\n  //If user supplies XML already, just use that.  XML Declaration should not be present.\n  if (params && params._xml) {\n    return params._xml;\n  }\n\n  var args = {};\n  args[name] = params;\n  var parameterTypeObj = type ? this.findSchemaObject(nsURI, type) : null;\n  return this.objectToXML(args, null, nsPrefix, nsURI, true, null, parameterTypeObj);\n};\n/**\r\n * Create RPC style xml string from the parameters\r\n * @param {String} name\r\n * @param {*} params\r\n * @param {String} nsPrefix\r\n * @param {String} nsURI\r\n * @returns {string}\r\n */\n\n\nWSDL.prototype.objectToRpcXML = function (name, params, nsPrefix, nsURI, isParts) {\n  var parts = [];\n  var defs = this.definitions;\n  var nsAttrName = '_xmlns';\n  nsPrefix = nsPrefix || findPrefix(defs.xmlns, nsURI);\n  nsURI = nsURI || defs.xmlns[nsPrefix];\n  nsPrefix = nsPrefix === TNS_PREFIX ? '' : nsPrefix + ':';\n  parts.push(['<', nsPrefix, name, '>'].join(''));\n\n  for (var key in params) {\n    if (!params.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (key !== nsAttrName) {\n      var value = params[key];\n      var prefixedKey = (isParts ? '' : nsPrefix) + key;\n      var attributes = [];\n\n      if (typeof value === 'object' && value.hasOwnProperty(this.options.attributesKey)) {\n        var attrs = value[this.options.attributesKey];\n\n        for (var n in attrs) {\n          attributes.push(' ' + n + '=' + '\"' + attrs[n] + '\"');\n        }\n      }\n\n      parts.push(['<', prefixedKey].concat(attributes).concat('>').join(''));\n      parts.push(typeof value === 'object' ? this.objectToXML(value, key, nsPrefix, nsURI) : xmlEscape(value));\n      parts.push(['</', prefixedKey, '>'].join(''));\n    }\n  }\n\n  parts.push(['</', nsPrefix, name, '>'].join(''));\n  return parts.join('');\n};\n\nfunction appendColon(ns) {\n  return ns && ns.charAt(ns.length - 1) !== ':' ? ns + ':' : ns;\n}\n\nfunction noColonNameSpace(ns) {\n  return ns && ns.charAt(ns.length - 1) === ':' ? ns.substring(0, ns.length - 1) : ns;\n}\n\nWSDL.prototype.isIgnoredNameSpace = function (ns) {\n  return this.options.ignoredNamespaces.indexOf(ns) > -1;\n};\n\nWSDL.prototype.filterOutIgnoredNameSpace = function (ns) {\n  var namespace = noColonNameSpace(ns);\n  return this.isIgnoredNameSpace(namespace) ? '' : namespace;\n};\n/**\r\n * Convert an object to XML.  This is a recursive method as it calls itself.\r\n *\r\n * @param {Object} obj the object to convert.\r\n * @param {String} name the name of the element (if the object being traversed is\r\n * an element).\r\n * @param {String} nsPrefix the namespace prefix of the object I.E. xsd.\r\n * @param {String} nsURI the full namespace of the object I.E. http://w3.org/schema.\r\n * @param {Boolean} isFirst whether or not this is the first item being traversed.\r\n * @param {?} xmlnsAttr\r\n * @param {?} parameterTypeObject\r\n * @param {NamespaceContext} nsContext Namespace context\r\n */\n\n\nWSDL.prototype.objectToXML = function (obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext) {\n  var self = this;\n  var schema = this.definitions.schemas[nsURI];\n  var parentNsPrefix = nsPrefix ? nsPrefix.parent : undefined;\n\n  if (typeof parentNsPrefix !== 'undefined') {\n    //we got the parentNsPrefix for our array. setting the namespace-variable back to the current namespace string\n    nsPrefix = nsPrefix.current;\n  }\n\n  parentNsPrefix = noColonNameSpace(parentNsPrefix);\n\n  if (this.isIgnoredNameSpace(parentNsPrefix)) {\n    parentNsPrefix = '';\n  }\n\n  var soapHeader = !schema;\n  var qualified = schema && schema.$elementFormDefault === 'qualified';\n  var parts = [];\n  var prefixNamespace = (nsPrefix || qualified) && nsPrefix !== TNS_PREFIX;\n  var xmlnsAttrib = '';\n\n  if (nsURI && isFirst) {\n    if (self.options.overrideRootElement && self.options.overrideRootElement.xmlnsAttributes) {\n      self.options.overrideRootElement.xmlnsAttributes.forEach(function (attribute) {\n        xmlnsAttrib += ' ' + attribute.name + '=\"' + attribute.value + '\"';\n      });\n    } else {\n      if (prefixNamespace && !this.isIgnoredNameSpace(nsPrefix)) {\n        // resolve the prefix namespace\n        xmlnsAttrib += ' xmlns:' + nsPrefix + '=\"' + nsURI + '\"';\n      } // only add default namespace if the schema elementFormDefault is qualified\n\n\n      if (qualified || soapHeader) xmlnsAttrib += ' xmlns=\"' + nsURI + '\"';\n    }\n  }\n\n  if (!nsContext) {\n    nsContext = new NamespaceContext();\n    nsContext.declareNamespace(nsPrefix, nsURI);\n  } else {\n    nsContext.pushContext();\n  } // explicitly use xmlns attribute if available\n\n\n  if (xmlnsAttr && !(self.options.overrideRootElement && self.options.overrideRootElement.xmlnsAttributes)) {\n    xmlnsAttrib = xmlnsAttr;\n  }\n\n  var ns = '';\n\n  if (self.options.overrideRootElement && isFirst) {\n    ns = self.options.overrideRootElement.namespace;\n  } else if (prefixNamespace && (qualified || isFirst || soapHeader) && !this.isIgnoredNameSpace(nsPrefix)) {\n    ns = nsPrefix;\n  }\n\n  var i, n; // start building out XML string.\n\n  if (Array.isArray(obj)) {\n    for (i = 0, n = obj.length; i < n; i++) {\n      var item = obj[i];\n      var arrayAttr = self.processAttributes(item, nsContext),\n          correctOuterNsPrefix = parentNsPrefix || ns; //using the parent namespace prefix if given\n\n      var body = self.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n      var openingTagParts = ['<', appendColon(correctOuterNsPrefix), name, arrayAttr, xmlnsAttrib];\n\n      if (body === '' && self.options.useEmptyTag) {\n        // Use empty (self-closing) tags if no contents\n        openingTagParts.push(' />');\n        parts.push(openingTagParts.join(''));\n      } else {\n        openingTagParts.push('>');\n\n        if (self.options.namespaceArrayElements || i === 0) {\n          parts.push(openingTagParts.join(''));\n        }\n\n        parts.push(body);\n\n        if (self.options.namespaceArrayElements || i === n - 1) {\n          parts.push(['</', appendColon(correctOuterNsPrefix), name, '>'].join(''));\n        }\n      }\n    }\n  } else if (typeof obj === 'object') {\n    for (name in obj) {\n      if (!obj.hasOwnProperty(name)) continue; //don't process attributes as element\n\n      if (name === self.options.attributesKey) {\n        continue;\n      } //Its the value of a xml object. Return it directly.\n\n\n      if (name === self.options.xmlKey) {\n        nsContext.popContext();\n        return obj[name];\n      } //Its the value of an item. Return it directly.\n\n\n      if (name === self.options.valueKey) {\n        nsContext.popContext();\n        return xmlEscape(obj[name]);\n      }\n\n      var child = obj[name];\n\n      if (typeof child === 'undefined') {\n        continue;\n      }\n\n      var attr = self.processAttributes(child, nsContext);\n      var value = '';\n      var nonSubNameSpace = '';\n      var emptyNonSubNameSpace = false;\n      var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);\n\n      if (nameWithNsRegex) {\n        nonSubNameSpace = nameWithNsRegex[1] + ':';\n        name = nameWithNsRegex[2];\n      } else if (name[0] === ':') {\n        emptyNonSubNameSpace = true;\n        name = name.substr(1);\n      }\n\n      if (isFirst) {\n        value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n      } else {\n        if (self.definitions.schemas) {\n          if (schema) {\n            var childSchemaObject = self.findChildSchemaObject(schemaObject, name); //find sub namespace if not a primitive\n\n            if (childSchemaObject && (childSchemaObject.$type && childSchemaObject.$type.indexOf('xsd:') === -1 || childSchemaObject.$ref || childSchemaObject.$name)) {\n              /*if the base name space of the children is not in the ingoredSchemaNamspaces we use it.\r\n               This is because in some services the child nodes do not need the baseNameSpace.\r\n               */\n              var childNsPrefix = '';\n              var childName = '';\n              var childNsURI;\n              var childXmlnsAttrib = '';\n              var elementQName = childSchemaObject.$ref || childSchemaObject.$name;\n\n              if (elementQName) {\n                elementQName = splitQName(elementQName);\n                childName = elementQName.name;\n\n                if (elementQName.prefix === TNS_PREFIX) {\n                  // Local element\n                  childNsURI = childSchemaObject.$targetNamespace;\n                  childNsPrefix = nsContext.registerNamespace(childNsURI);\n\n                  if (this.isIgnoredNameSpace(childNsPrefix)) {\n                    childNsPrefix = nsPrefix;\n                  }\n                } else {\n                  childNsPrefix = elementQName.prefix;\n\n                  if (this.isIgnoredNameSpace(childNsPrefix)) {\n                    childNsPrefix = nsPrefix;\n                  }\n\n                  childNsURI = schema.xmlns[childNsPrefix] || self.definitions.xmlns[childNsPrefix];\n                }\n\n                var unqualified = false; // Check qualification form for local elements\n\n                if (childSchemaObject.$name && childSchemaObject.targetNamespace === undefined) {\n                  if (childSchemaObject.$form === 'unqualified') {\n                    unqualified = true;\n                  } else if (childSchemaObject.$form === 'qualified') {\n                    unqualified = false;\n                  } else {\n                    unqualified = schema.$elementFormDefault !== 'qualified';\n                  }\n                }\n\n                if (unqualified) {\n                  childNsPrefix = '';\n                }\n\n                if (childNsURI && childNsPrefix) {\n                  if (nsContext.declareNamespace(childNsPrefix, childNsURI)) {\n                    childXmlnsAttrib = ' xmlns:' + childNsPrefix + '=\"' + childNsURI + '\"';\n                    xmlnsAttrib += childXmlnsAttrib;\n                  }\n                }\n              }\n\n              var resolvedChildSchemaObject;\n\n              if (childSchemaObject.$type) {\n                var typeQName = splitQName(childSchemaObject.$type);\n                var typePrefix = typeQName.prefix;\n                var typeURI = schema.xmlns[typePrefix] || self.definitions.xmlns[typePrefix];\n                childNsURI = typeURI;\n\n                if (typeURI !== 'http://www.w3.org/2001/XMLSchema' && typePrefix !== TNS_PREFIX) {\n                  // Add the prefix/namespace mapping, but not declare it\n                  nsContext.addNamespace(typePrefix, typeURI);\n                }\n\n                resolvedChildSchemaObject = self.findSchemaType(typeQName.name, typeURI) || childSchemaObject;\n              } else {\n                resolvedChildSchemaObject = self.findSchemaObject(childNsURI, childName) || childSchemaObject;\n              }\n\n              if (childSchemaObject.$baseNameSpace && this.options.ignoreBaseNameSpaces) {\n                childNsPrefix = nsPrefix;\n                childNsURI = nsURI;\n              }\n\n              if (this.options.ignoreBaseNameSpaces) {\n                childNsPrefix = '';\n                childNsURI = '';\n              }\n\n              ns = childNsPrefix;\n\n              if (Array.isArray(child)) {\n                //for arrays, we need to remember the current namespace\n                childNsPrefix = {\n                  current: childNsPrefix,\n                  parent: ns\n                };\n              } else {\n                //parent (array) already got the namespace\n                childXmlnsAttrib = null;\n              }\n\n              value = self.objectToXML(child, name, childNsPrefix, childNsURI, false, childXmlnsAttrib, resolvedChildSchemaObject, nsContext);\n            } else if (obj[self.options.attributesKey] && obj[self.options.attributesKey].xsi_type) {\n              //if parent object has complex type defined and child not found in parent\n              var completeChildParamTypeObject = self.findChildSchemaObject(obj[self.options.attributesKey].xsi_type.type, obj[self.options.attributesKey].xsi_type.xmlns);\n              nonSubNameSpace = obj[self.options.attributesKey].xsi_type.prefix;\n              nsContext.addNamespace(obj[self.options.attributesKey].xsi_type.prefix, obj[self.options.attributesKey].xsi_type.xmlns);\n              value = self.objectToXML(child, name, obj[self.options.attributesKey].xsi_type.prefix, obj[self.options.attributesKey].xsi_type.xmlns, false, null, null, nsContext);\n            } else {\n              if (Array.isArray(child)) {\n                name = nonSubNameSpace + name;\n              }\n\n              value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n            }\n          } else {\n            value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n          }\n        }\n      }\n\n      ns = noColonNameSpace(ns);\n\n      if (prefixNamespace && !qualified && isFirst && !self.options.overrideRootElement) {\n        ns = nsPrefix;\n      } else if (this.isIgnoredNameSpace(ns)) {\n        ns = '';\n      }\n\n      var useEmptyTag = !value && self.options.useEmptyTag;\n\n      if (!Array.isArray(child)) {\n        // start tag\n        parts.push(['<', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, attr, xmlnsAttrib, child === null ? ' xsi:nil=\"true\"' : '', useEmptyTag ? ' />' : '>'].join(''));\n      }\n\n      if (!useEmptyTag) {\n        parts.push(value);\n\n        if (!Array.isArray(child)) {\n          // end tag\n          parts.push(['</', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, '>'].join(''));\n        }\n      }\n    }\n  } else if (obj !== undefined) {\n    parts.push(self.options.escapeXML ? xmlEscape(obj) : obj);\n  }\n\n  nsContext.popContext();\n  return parts.join('');\n};\n\nWSDL.prototype.processAttributes = function (child, nsContext) {\n  var attr = '';\n\n  if (child === null) {\n    child = [];\n  }\n\n  var attrObj = child[this.options.attributesKey];\n\n  if (attrObj && attrObj.xsi_type) {\n    var xsiType = attrObj.xsi_type;\n    var prefix = xsiType.prefix || xsiType.namespace; // Generate a new namespace for complex extension if one not provided\n\n    if (!prefix) {\n      prefix = nsContext.registerNamespace(xsiType.xmlns);\n    } else {\n      nsContext.declareNamespace(prefix, xsiType.xmlns);\n    }\n\n    xsiType.prefix = prefix;\n  }\n\n  if (attrObj) {\n    for (var attrKey in attrObj) {\n      //handle complex extension separately\n      if (attrKey === 'xsi_type') {\n        var attrValue = attrObj[attrKey];\n        attr += ' xsi:type=\"' + attrValue.prefix + ':' + attrValue.type + '\"';\n        attr += ' xmlns:' + attrValue.prefix + '=\"' + attrValue.xmlns + '\"';\n        continue;\n      } else {\n        attr += ' ' + attrKey + '=\"' + xmlEscape(attrObj[attrKey]) + '\"';\n      }\n    }\n  }\n\n  return attr;\n};\n/**\r\n * Look up a schema type definition\r\n * @param name\r\n * @param nsURI\r\n * @returns {*}\r\n */\n\n\nWSDL.prototype.findSchemaType = function (name, nsURI) {\n  if (!this.definitions.schemas || !name || !nsURI) {\n    return null;\n  }\n\n  var schema = this.definitions.schemas[nsURI];\n\n  if (!schema || !schema.complexTypes) {\n    return null;\n  }\n\n  return schema.complexTypes[name];\n};\n\nWSDL.prototype.findChildSchemaObject = function (parameterTypeObj, childName, backtrace) {\n  if (!parameterTypeObj || !childName) {\n    return null;\n  }\n\n  if (!backtrace) {\n    backtrace = [];\n  }\n\n  if (backtrace.indexOf(parameterTypeObj) >= 0) {\n    // We've recursed back to ourselves; break.\n    return null;\n  } else {\n    backtrace = backtrace.concat([parameterTypeObj]);\n  }\n\n  var found = null,\n      i = 0,\n      child,\n      ref;\n\n  if (Array.isArray(parameterTypeObj.$lookupTypes) && parameterTypeObj.$lookupTypes.length) {\n    var types = parameterTypeObj.$lookupTypes;\n\n    for (i = 0; i < types.length; i++) {\n      var typeObj = types[i];\n\n      if (typeObj.$name === childName) {\n        found = typeObj;\n        break;\n      }\n    }\n  }\n\n  var object = parameterTypeObj;\n\n  if (object.$name === childName && object.name === 'element') {\n    return object;\n  }\n\n  if (object.$ref) {\n    ref = splitQName(object.$ref);\n\n    if (ref.name === childName) {\n      return object;\n    }\n  }\n\n  var childNsURI; // want to avoid unecessary recursion to improve performance\n\n  if (object.$type && backtrace.length === 1) {\n    var typeInfo = splitQName(object.$type);\n\n    if (typeInfo.prefix === TNS_PREFIX) {\n      childNsURI = parameterTypeObj.$targetNamespace;\n    } else {\n      childNsURI = this.definitions.xmlns[typeInfo.prefix];\n    }\n\n    var typeDef = this.findSchemaType(typeInfo.name, childNsURI);\n\n    if (typeDef) {\n      return this.findChildSchemaObject(typeDef, childName, backtrace);\n    }\n  }\n\n  if (object.children) {\n    for (i = 0, child; child = object.children[i]; i++) {\n      found = this.findChildSchemaObject(child, childName, backtrace);\n\n      if (found) {\n        break;\n      }\n\n      if (child.$base) {\n        var baseQName = splitQName(child.$base);\n        var childNameSpace = baseQName.prefix === TNS_PREFIX ? '' : baseQName.prefix;\n        childNsURI = child.xmlns[baseQName.prefix] || this.definitions.xmlns[baseQName.prefix];\n        var foundBase = this.findSchemaType(baseQName.name, childNsURI);\n\n        if (foundBase) {\n          found = this.findChildSchemaObject(foundBase, childName, backtrace);\n\n          if (found) {\n            found.$baseNameSpace = childNameSpace;\n            found.$type = childNameSpace + ':' + childName;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (!found && object.$name === childName) {\n    return object;\n  }\n\n  return found;\n};\n\nWSDL.prototype._parse = function (xml) {\n  var self = this,\n      p = sax.parser(true),\n      stack = [],\n      root = null,\n      types = null,\n      schema = null,\n      schemaAttrs = null,\n      options = self.options;\n\n  p.onopentag = function (node) {\n    var nsName = node.name;\n    var attrs = node.attributes;\n    var top = stack[stack.length - 1];\n    var name = splitQName(nsName).name;\n\n    if (name === 'schema') {\n      schemaAttrs = attrs;\n    }\n\n    if (top) {\n      try {\n        top.startElement(stack, nsName, attrs, options, schemaAttrs);\n      } catch (e) {\n        if (self.options.strict) {\n          throw e;\n        } else {\n          stack.push(new Element(nsName, attrs, options, schemaAttrs));\n        }\n      }\n    } else {\n      if (name === 'definitions') {\n        root = new DefinitionsElement(nsName, attrs, options);\n        stack.push(root);\n      } else if (name === 'schema') {\n        // Shim a structure in here to allow the proper objects to be created when merging back.\n        root = new DefinitionsElement('definitions', {}, {});\n        types = new TypesElement('types', {}, {});\n        schema = new SchemaElement(nsName, attrs, options);\n        types.addChild(schema);\n        root.addChild(types);\n        stack.push(schema);\n      } else {\n        throw new Error('Unexpected root element of WSDL or include');\n      }\n    }\n  };\n\n  p.onclosetag = function (name) {\n    var top = stack[stack.length - 1];\n    assert(top, 'Unmatched close tag: ' + name);\n    top.endElement(stack, name);\n  };\n\n  p.write(xml).close();\n  return root;\n};\n\nWSDL.prototype._fromXML = function (xml) {\n  this.definitions = this._parse(xml);\n  this.definitions.descriptions = {\n    types: {}\n  };\n  this.xml = xml;\n};\n\nWSDL.prototype._fromServices = function (services) {};\n\nWSDL.prototype._xmlnsMap = function () {\n  var xmlns = this.definitions.xmlns;\n  var str = '';\n\n  for (var alias in xmlns) {\n    if (alias === '' || alias === TNS_PREFIX) {\n      continue;\n    }\n\n    var ns = xmlns[alias];\n\n    switch (ns) {\n      case \"http://xml.apache.org/xml-soap\": // apachesoap\n\n      case \"http://schemas.xmlsoap.org/wsdl/\": // wsdl\n\n      case \"http://schemas.xmlsoap.org/wsdl/soap/\": // wsdlsoap\n\n      case \"http://schemas.xmlsoap.org/wsdl/soap12/\": // wsdlsoap12\n\n      case \"http://schemas.xmlsoap.org/soap/encoding/\": // soapenc\n\n      case \"http://www.w3.org/2001/XMLSchema\":\n        // xsd\n        continue;\n    }\n\n    if (~ns.indexOf('http://schemas.xmlsoap.org/')) {\n      continue;\n    }\n\n    if (~ns.indexOf('http://www.w3.org/')) {\n      continue;\n    }\n\n    if (~ns.indexOf('http://xml.apache.org/')) {\n      continue;\n    }\n\n    str += ' xmlns:' + alias + '=\"' + ns + '\"';\n  }\n\n  return str;\n};\n/*\r\n * Have another function to load previous WSDLs as we\r\n * don't want this to be invoked externally (expect for tests)\r\n * This will attempt to fix circular dependencies with XSD files,\r\n * Given\r\n * - file.wsdl\r\n *   - xs:import namespace=\"A\" schemaLocation: A.xsd\r\n * - A.xsd\r\n *   - xs:import namespace=\"B\" schemaLocation: B.xsd\r\n * - B.xsd\r\n *   - xs:import namespace=\"A\" schemaLocation: A.xsd\r\n * file.wsdl will start loading, import A, then A will import B, which will then import A\r\n * Because A has already started to load previously it will be returned right away and\r\n * have an internal circular reference\r\n * B would then complete loading, then A, then file.wsdl\r\n * By the time file A starts processing its includes its definitions will be already loaded,\r\n * this is the only thing that B will depend on when \"opening\" A\r\n */\n\n\nfunction open_wsdl_recursive(uri, options, callback) {\n  var fromCache, WSDL_CACHE;\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  WSDL_CACHE = options.WSDL_CACHE;\n\n  if (fromCache = WSDL_CACHE[uri]) {\n    return callback.call(fromCache, null, fromCache);\n  }\n\n  return open_wsdl(uri, options, callback);\n}\n\nfunction open_wsdl(uri, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } // initialize cache when calling open_wsdl directly\n\n\n  var WSDL_CACHE = options.WSDL_CACHE || {};\n  var request_headers = options.wsdl_headers;\n  var request_options = options.wsdl_options;\n  var wsdl;\n\n  if (!/^https?:/.test(uri)) {\n    debug('Reading file: %s', uri);\n    fs.readFile(uri, 'utf8', function (err, definition) {\n      if (err) {\n        callback(err);\n      } else {\n        wsdl = new WSDL(definition, uri, options);\n        WSDL_CACHE[uri] = wsdl;\n        wsdl.WSDL_CACHE = WSDL_CACHE;\n        wsdl.onReady(callback);\n      }\n    });\n  } else {\n    debug('Reading url: %s', uri);\n    var httpClient = options.httpClient || new HttpClient(options);\n    httpClient.request(uri, null\n    /* options */\n    , function (err, response, definition) {\n      if (err) {\n        callback(err);\n      } else if (response && response.statusCode === 200) {\n        wsdl = new WSDL(definition, uri, options);\n        WSDL_CACHE[uri] = wsdl;\n        wsdl.WSDL_CACHE = WSDL_CACHE;\n        wsdl.onReady(callback);\n      } else {\n        callback(new Error('Invalid WSDL URL: ' + uri + \"\\n\\n\\r Code: \" + response.statusCode + \"\\n\\n\\r Response Body: \" + response.body));\n      }\n    }, request_headers, request_options);\n  }\n\n  return wsdl;\n}\n\nexports.open_wsdl = open_wsdl;\nexports.WSDL = WSDL;","map":null,"metadata":{},"sourceType":"script"}