{"ast":null,"code":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n */\n\"use strict\";\n\nfunction getDateString(d) {\n  function pad(n) {\n    return n < 10 ? '0' + n : n;\n  }\n\n  return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + 'Z';\n}\n\nvar url = require('url'),\n    zlib = null,\n    events = require('events'),\n    util = require('util'),\n    findPrefix = require('./utils').findPrefix;\n\ntry {\n  zlib = require(\"zlib\");\n} catch (error) {}\n\nvar Server = function Server(server, path, services, wsdl, options) {\n  var self = this;\n  events.EventEmitter.call(this);\n  options = options || {};\n  this.path = path;\n  this.services = services;\n  this.wsdl = wsdl;\n  this.suppressStack = options && options.suppressStack;\n  this.returnFault = options && options.returnFault;\n  this.onewayOptions = options && options.oneWay || {};\n  if (path[path.length - 1] !== '/') path += '/';\n  wsdl.onReady(function (err) {\n    if (typeof server.route === 'function' && typeof server.use === 'function') {\n      //handle only the required URL path for express server\n      server.route(path).all(function (req, res, next) {\n        if (typeof self.authorizeConnection === 'function') {\n          if (!self.authorizeConnection(req, res)) {\n            res.end();\n            return;\n          }\n        }\n\n        self._requestListener(req, res);\n      });\n    } else {\n      var listeners = server.listeners('request').slice();\n      server.removeAllListeners('request');\n      server.addListener('request', function (req, res) {\n        if (typeof self.authorizeConnection === 'function') {\n          if (!self.authorizeConnection(req, res)) {\n            res.end();\n            return;\n          }\n        }\n\n        var reqPath = url.parse(req.url).pathname;\n\n        if (reqPath[reqPath.length - 1] !== '/') {\n          reqPath += '/';\n        }\n\n        if (path === reqPath) {\n          self._requestListener(req, res);\n        } else {\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            listeners[i].call(this, req, res);\n          }\n        }\n      });\n    }\n  });\n\n  this._initializeOptions(options);\n};\n\nutil.inherits(Server, events.EventEmitter);\n\nServer.prototype._processSoapHeader = function (soapHeader, name, namespace, xmlns) {\n  var self = this;\n\n  switch (typeof soapHeader) {\n    case 'object':\n      return this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\n\n    case 'function':\n      return function () {\n        var result = soapHeader.apply(null, arguments);\n\n        if (typeof result === 'object') {\n          return self.wsdl.objectToXML(result, name, namespace, xmlns, true);\n        } else {\n          return result;\n        }\n      };\n\n    default:\n      return soapHeader;\n  }\n};\n\nServer.prototype.addSoapHeader = function (soapHeader, name, namespace, xmlns) {\n  if (!this.soapHeaders) {\n    this.soapHeaders = [];\n  }\n\n  soapHeader = this._processSoapHeader(soapHeader, name, namespace, xmlns);\n  return this.soapHeaders.push(soapHeader) - 1;\n};\n\nServer.prototype.changeSoapHeader = function (index, soapHeader, name, namespace, xmlns) {\n  if (!this.soapHeaders) {\n    this.soapHeaders = [];\n  }\n\n  soapHeader = this._processSoapHeader(soapHeader, name, namespace, xmlns);\n  this.soapHeaders[index] = soapHeader;\n};\n\nServer.prototype.getSoapHeaders = function () {\n  return this.soapHeaders;\n};\n\nServer.prototype.clearSoapHeaders = function () {\n  this.soapHeaders = null;\n};\n\nServer.prototype._initializeOptions = function (options) {\n  this.wsdl.options.attributesKey = options.attributesKey || 'attributes';\n  this.onewayOptions.statusCode = this.onewayOptions.responseCode || 200;\n  this.onewayOptions.emptyBody = !!this.onewayOptions.emptyBody;\n};\n\nServer.prototype._processRequestXml = function (req, res, xml) {\n  var self = this;\n  var result;\n  var error;\n\n  try {\n    if (typeof self.log === 'function') {\n      self.log(\"received\", xml);\n    }\n\n    self._process(xml, req, function (result, statusCode) {\n      if (statusCode) {\n        res.statusCode = statusCode;\n      }\n\n      res.write(result);\n      res.end();\n\n      if (typeof self.log === 'function') {\n        self.log(\"replied\", result);\n      }\n    });\n  } catch (err) {\n    if (err.Fault !== undefined) {\n      return self._sendError(err.Fault, function (result, statusCode) {\n        res.statusCode = statusCode || 500;\n        res.write(result);\n        res.end();\n\n        if (typeof self.log === 'function') {\n          self.log(\"error\", err);\n        }\n      }, new Date().toISOString());\n    } else {\n      error = err.stack ? self.suppressStack === true ? err.message : err.stack : err;\n      res.statusCode = 500;\n      res.write(error);\n      res.end();\n\n      if (typeof self.log === 'function') {\n        self.log(\"error\", error);\n      }\n    }\n  }\n};\n\nServer.prototype._requestListener = function (req, res) {\n  var self = this;\n  var reqParse = url.parse(req.url);\n  var reqPath = reqParse.pathname;\n  var reqQuery = reqParse.search;\n\n  if (typeof self.log === 'function') {\n    self.log(\"info\", \"Handling \" + req.method + \" on \" + req.url);\n  }\n\n  if (req.method === 'GET') {\n    if (reqQuery && reqQuery.toLowerCase() === '?wsdl') {\n      if (typeof self.log === 'function') {\n        self.log(\"info\", \"Wants the WSDL\");\n      }\n\n      res.setHeader(\"Content-Type\", \"application/xml\");\n      res.write(self.wsdl.toXML());\n    }\n\n    res.end();\n  } else if (req.method === 'POST') {\n    if (typeof req.headers['content-type'] !== \"undefined\") {\n      res.setHeader('Content-Type', req.headers['content-type']);\n    } else {\n      res.setHeader('Content-Type', \"application/xml\");\n    } //request body is already provided by an express middleware\n    //in this case unzipping should also be done by the express middleware itself\n\n\n    if (req.body) {\n      return self._processRequestXml(req, res, req.body.toString());\n    }\n\n    var chunks = [],\n        gunzip,\n        source = req;\n\n    if (req.headers[\"content-encoding\"] === \"gzip\") {\n      gunzip = zlib.createGunzip();\n      req.pipe(gunzip);\n      source = gunzip;\n    }\n\n    source.on('data', function (chunk) {\n      chunks.push(chunk);\n    });\n    source.on('end', function () {\n      var xml = chunks.join('');\n      var result;\n      var error;\n\n      self._processRequestXml(req, res, xml);\n    });\n  } else {\n    res.end();\n  }\n};\n\nServer.prototype._process = function (input, req, callback) {\n  var self = this,\n      pathname = url.parse(req.url).pathname.replace(/\\/$/, ''),\n      obj = this.wsdl.xmlToObject(input),\n      body = obj.Body,\n      headers = obj.Header,\n      bindings = this.wsdl.definitions.bindings,\n      binding,\n      method,\n      methodName,\n      serviceName,\n      portName,\n      includeTimestamp = obj.Header && obj.Header.Security && obj.Header.Security.Timestamp,\n      authenticate = self.authenticate || function defaultAuthenticate() {\n    return true;\n  };\n\n  function process() {\n    if (typeof self.log === 'function') {\n      self.log(\"info\", \"Attempting to bind to \" + pathname);\n    } //Avoid Cannot convert undefined or null to object due to Object.keys(body)\n    //and throw more meaningful error\n\n\n    if (!body) {\n      throw new Error('Failed to parse the SOAP Message body');\n    } // use port.location and current url to find the right binding\n\n\n    binding = function () {\n      var services = self.wsdl.definitions.services;\n      var firstPort;\n      var name;\n\n      for (name in services) {\n        serviceName = name;\n        var service = services[serviceName];\n        var ports = service.ports;\n\n        for (name in ports) {\n          portName = name;\n          var port = ports[portName];\n          var portPathname = url.parse(port.location).pathname.replace(/\\/$/, '');\n\n          if (typeof self.log === 'function') {\n            self.log(\"info\", \"Trying \" + portName + \" from path \" + portPathname);\n          }\n\n          if (portPathname === pathname) return port.binding; // The port path is almost always wrong for generated WSDLs\n\n          if (!firstPort) {\n            firstPort = port;\n          }\n        }\n      }\n\n      return !firstPort ? void 0 : firstPort.binding;\n    }();\n\n    if (!binding) {\n      throw new Error('Failed to bind to WSDL');\n    }\n\n    try {\n      if (binding.style === 'rpc') {\n        methodName = Object.keys(body)[0];\n        self.emit('request', obj, methodName);\n        if (headers) self.emit('headers', headers, methodName);\n\n        self._executeMethod({\n          serviceName: serviceName,\n          portName: portName,\n          methodName: methodName,\n          outputName: methodName + 'Response',\n          args: body[methodName],\n          headers: headers,\n          style: 'rpc'\n        }, req, callback);\n      } else {\n        var messageElemName = Object.keys(body)[0] === 'attributes' ? Object.keys(body)[1] : Object.keys(body)[0];\n        var pair = binding.topElements[messageElemName];\n        self.emit('request', obj, pair.methodName);\n        if (headers) self.emit('headers', headers, pair.methodName);\n\n        self._executeMethod({\n          serviceName: serviceName,\n          portName: portName,\n          methodName: pair.methodName,\n          outputName: pair.outputName,\n          args: body[messageElemName],\n          headers: headers,\n          style: 'document'\n        }, req, callback, includeTimestamp);\n      }\n    } catch (error) {\n      if (error.Fault !== undefined) {\n        return self._sendError(error.Fault, callback, includeTimestamp);\n      }\n\n      throw error;\n    }\n  } // Authentication\n\n\n  if (typeof authenticate === 'function') {\n    var authResultProcessed = false,\n        processAuthResult = function processAuthResult(authResult) {\n      if (!authResultProcessed && (authResult || authResult === false)) {\n        authResultProcessed = true;\n\n        if (authResult) {\n          try {\n            process();\n          } catch (error) {\n            if (error.Fault !== undefined) {\n              return self._sendError(error.Fault, callback, includeTimestamp);\n            }\n\n            return self._sendError({\n              Code: {\n                Value: 'SOAP-ENV:Server',\n                Subcode: {\n                  value: 'InternalServerError'\n                }\n              },\n              Reason: {\n                Text: error.toString()\n              },\n              statusCode: 500\n            }, callback, includeTimestamp);\n          }\n        } else {\n          return self._sendError({\n            Code: {\n              Value: 'SOAP-ENV:Client',\n              Subcode: {\n                value: 'AuthenticationFailure'\n              }\n            },\n            Reason: {\n              Text: 'Invalid username or password'\n            },\n            statusCode: 401\n          }, callback, includeTimestamp);\n        }\n      }\n    };\n\n    processAuthResult(authenticate(obj.Header && obj.Header.Security, processAuthResult));\n  } else {\n    throw new Error('Invalid authenticate function (not a function)');\n  }\n};\n\nServer.prototype._executeMethod = function (options, req, callback, includeTimestamp) {\n  options = options || {};\n  var self = this,\n      method,\n      body,\n      headers,\n      serviceName = options.serviceName,\n      portName = options.portName,\n      methodName = options.methodName,\n      outputName = options.outputName,\n      args = options.args,\n      style = options.style,\n      handled = false;\n\n  if (this.soapHeaders) {\n    headers = this.soapHeaders.map(function (header) {\n      if (typeof header === 'function') {\n        return header(methodName, args, options.headers, req);\n      } else {\n        return header;\n      }\n    }).join(\"\\n\");\n  }\n\n  try {\n    method = this.services[serviceName][portName][methodName];\n  } catch (error) {\n    return callback(this._envelope('', headers, includeTimestamp));\n  }\n\n  function handleResult(error, result) {\n    if (handled) return;\n    handled = true;\n\n    if (error && error.Fault !== undefined) {\n      return self._sendError(error.Fault, callback, includeTimestamp);\n    } else if (result === undefined) {\n      // Backward compatibility to support one argument callback style\n      result = error;\n    }\n\n    if (style === 'rpc') {\n      body = self.wsdl.objectToRpcXML(outputName, result, '', self.wsdl.definitions.$targetNamespace);\n    } else {\n      var element = self.wsdl.definitions.services[serviceName].ports[portName].binding.methods[methodName].output;\n      body = self.wsdl.objectToDocumentXML(outputName, result, element.targetNSAlias, element.targetNamespace);\n    }\n\n    callback(self._envelope(body, headers, includeTimestamp));\n  }\n\n  if (!self.wsdl.definitions.services[serviceName].ports[portName].binding.methods[methodName].output) {\n    // no output defined = one-way operation so return empty response\n    handled = true;\n    body = '';\n\n    if (this.onewayOptions.emptyBody) {\n      body = self._envelope('', headers, includeTimestamp);\n    }\n\n    callback(body, this.onewayOptions.responseCode);\n  }\n\n  var result = method(args, handleResult, options.headers, req);\n\n  if (typeof result !== 'undefined') {\n    handleResult(result);\n  }\n};\n\nServer.prototype._envelope = function (body, headers, includeTimestamp) {\n  var defs = this.wsdl.definitions,\n      ns = defs.$targetNamespace,\n      encoding = '',\n      alias = findPrefix(defs.xmlns, ns);\n  var envelopeDefinition = this.wsdl.options.forceSoap12Headers ? \"http://www.w3.org/2003/05/soap-envelope\" : \"http://schemas.xmlsoap.org/soap/envelope/\";\n  var xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" + \"<soap:Envelope xmlns:soap=\\\"\" + envelopeDefinition + \"\\\" \" + encoding + this.wsdl.xmlnsInEnvelope + '>';\n  headers = headers || '';\n\n  if (includeTimestamp) {\n    var now = new Date();\n    var created = getDateString(now);\n    var expires = getDateString(new Date(now.getTime() + 1000 * 600));\n    headers += \"<o:Security soap:mustUnderstand=\\\"1\\\" \" + \"xmlns:o=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\\\" \" + \"xmlns:u=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\\\">\" + \"    <u:Timestamp u:Id=\\\"_0\\\">\" + \"      <u:Created>\" + created + \"</u:Created>\" + \"      <u:Expires>\" + expires + \"</u:Expires>\" + \"    </u:Timestamp>\" + \"  </o:Security>\\n\";\n  }\n\n  if (headers !== '') {\n    xml += \"<soap:Header>\" + headers + \"</soap:Header>\";\n  }\n\n  xml += body ? \"<soap:Body>\" + body + \"</soap:Body>\" : \"<soap:Body/>\";\n  xml += \"</soap:Envelope>\";\n  return xml;\n};\n\nServer.prototype._sendError = function (soapFault, callback, includeTimestamp) {\n  var self = this,\n      fault;\n  var statusCode;\n\n  if (soapFault.statusCode) {\n    statusCode = soapFault.statusCode;\n    soapFault.statusCode = undefined;\n  }\n\n  if (soapFault.faultcode) {\n    // Soap 1.1 error style\n    // Root element will be prependend with the soap NS\n    // It must match the NS defined in the Envelope (set by the _envelope method)\n    fault = self.wsdl.objectToDocumentXML(\"soap:Fault\", soapFault, undefined);\n  } else {\n    // Soap 1.2 error style.\n    // 3rd param is the NS prepended to all elements\n    // It must match the NS defined in the Envelope (set by the _envelope method)\n    fault = self.wsdl.objectToDocumentXML(\"Fault\", soapFault, \"soap\");\n  }\n\n  return callback(self._envelope(fault, '', includeTimestamp), statusCode);\n};\n\nexports.Server = Server;","map":null,"metadata":{},"sourceType":"script"}