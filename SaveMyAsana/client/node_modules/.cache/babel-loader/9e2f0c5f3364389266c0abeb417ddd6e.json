{"ast":null,"code":"/**\n * Copyright (c) 2013 Sam Decrock https://github.com/SamDecrock/\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar crypto = require('crypto');\n\nvar flags = {\n  NTLM_NegotiateUnicode: 0x00000001,\n  NTLM_NegotiateOEM: 0x00000002,\n  NTLM_RequestTarget: 0x00000004,\n  NTLM_Unknown9: 0x00000008,\n  NTLM_NegotiateSign: 0x00000010,\n  NTLM_NegotiateSeal: 0x00000020,\n  NTLM_NegotiateDatagram: 0x00000040,\n  NTLM_NegotiateLanManagerKey: 0x00000080,\n  NTLM_Unknown8: 0x00000100,\n  NTLM_NegotiateNTLM: 0x00000200,\n  NTLM_NegotiateNTOnly: 0x00000400,\n  NTLM_Anonymous: 0x00000800,\n  NTLM_NegotiateOemDomainSupplied: 0x00001000,\n  NTLM_NegotiateOemWorkstationSupplied: 0x00002000,\n  NTLM_Unknown6: 0x00004000,\n  NTLM_NegotiateAlwaysSign: 0x00008000,\n  NTLM_TargetTypeDomain: 0x00010000,\n  NTLM_TargetTypeServer: 0x00020000,\n  NTLM_TargetTypeShare: 0x00040000,\n  NTLM_NegotiateExtendedSecurity: 0x00080000,\n  NTLM_NegotiateIdentify: 0x00100000,\n  NTLM_Unknown5: 0x00200000,\n  NTLM_RequestNonNTSessionKey: 0x00400000,\n  NTLM_NegotiateTargetInfo: 0x00800000,\n  NTLM_Unknown4: 0x01000000,\n  NTLM_NegotiateVersion: 0x02000000,\n  NTLM_Unknown3: 0x04000000,\n  NTLM_Unknown2: 0x08000000,\n  NTLM_Unknown1: 0x10000000,\n  NTLM_Negotiate128: 0x20000000,\n  NTLM_NegotiateKeyExchange: 0x40000000,\n  NTLM_Negotiate56: 0x80000000\n};\nvar typeflags = {\n  NTLM_TYPE1_FLAGS: flags.NTLM_NegotiateUnicode + flags.NTLM_NegotiateOEM + flags.NTLM_RequestTarget + flags.NTLM_NegotiateNTLM + flags.NTLM_NegotiateOemDomainSupplied + flags.NTLM_NegotiateOemWorkstationSupplied + flags.NTLM_NegotiateAlwaysSign + flags.NTLM_NegotiateExtendedSecurity + flags.NTLM_NegotiateVersion + flags.NTLM_Negotiate128 + flags.NTLM_Negotiate56,\n  NTLM_TYPE2_FLAGS: flags.NTLM_NegotiateUnicode + flags.NTLM_RequestTarget + flags.NTLM_NegotiateNTLM + flags.NTLM_NegotiateAlwaysSign + flags.NTLM_NegotiateExtendedSecurity + flags.NTLM_NegotiateTargetInfo + flags.NTLM_NegotiateVersion + flags.NTLM_Negotiate128 + flags.NTLM_Negotiate56\n};\n\nfunction createType1Message(options) {\n  var domain = escape(options.domain.toUpperCase());\n  var workstation = escape(options.workstation.toUpperCase());\n  var protocol = 'NTLMSSP\\0';\n  var BODY_LENGTH = 40;\n  var type1flags = typeflags.NTLM_TYPE1_FLAGS;\n  if (!domain || domain === '') type1flags = type1flags - flags.NTLM_NegotiateOemDomainSupplied;\n  var pos = 0;\n  var buf = new Buffer(BODY_LENGTH + domain.length + workstation.length);\n  buf.write(protocol, pos, protocol.length);\n  pos += protocol.length; // protocol\n\n  buf.writeUInt32LE(1, pos);\n  pos += 4; // type 1\n\n  buf.writeUInt32LE(type1flags, pos);\n  pos += 4; // TYPE1 flag\n\n  buf.writeUInt16LE(domain.length, pos);\n  pos += 2; // domain length\n\n  buf.writeUInt16LE(domain.length, pos);\n  pos += 2; // domain max length\n\n  buf.writeUInt32LE(BODY_LENGTH + workstation.length, pos);\n  pos += 4; // domain buffer offset\n\n  buf.writeUInt16LE(workstation.length, pos);\n  pos += 2; // workstation length\n\n  buf.writeUInt16LE(workstation.length, pos);\n  pos += 2; // workstation max length\n\n  buf.writeUInt32LE(BODY_LENGTH, pos);\n  pos += 4; // workstation buffer offset\n\n  buf.writeUInt8(5, pos);\n  pos += 1; //ProductMajorVersion\n\n  buf.writeUInt8(1, pos);\n  pos += 1; //ProductMinorVersion\n\n  buf.writeUInt16LE(2600, pos);\n  pos += 2; //ProductBuild\n\n  buf.writeUInt8(0, pos);\n  pos += 1; //VersionReserved1\n\n  buf.writeUInt8(0, pos);\n  pos += 1; //VersionReserved2\n\n  buf.writeUInt8(0, pos);\n  pos += 1; //VersionReserved3\n\n  buf.writeUInt8(15, pos);\n  pos += 1; //NTLMRevisionCurrent\n  // length checks is to fix issue #46 and possibly #57\n\n  if (workstation.length != 0) buf.write(workstation, pos, workstation.length, 'ascii');\n  pos += workstation.length; // workstation string\n\n  if (domain.length != 0) buf.write(domain, pos, domain.length, 'ascii');\n  pos += domain.length; // domain string\n\n  return 'NTLM ' + buf.toString('base64');\n}\n\nfunction parseType2Message(rawmsg, callback) {\n  var match = rawmsg.match(/NTLM (.+)?/);\n\n  if (!match || !match[1]) {\n    callback(new Error(\"Couldn't find NTLM in the message type2 comming from the server\"));\n    return null;\n  }\n\n  var buf = new Buffer(match[1], 'base64');\n  var msg = {};\n  msg.signature = buf.slice(0, 8);\n  msg.type = buf.readInt16LE(8);\n\n  if (msg.type != 2) {\n    callback(new Error(\"Server didn't return a type 2 message\"));\n    return null;\n  }\n\n  msg.targetNameLen = buf.readInt16LE(12);\n  msg.targetNameMaxLen = buf.readInt16LE(14);\n  msg.targetNameOffset = buf.readInt32LE(16);\n  msg.targetName = buf.slice(msg.targetNameOffset, msg.targetNameOffset + msg.targetNameMaxLen);\n  msg.negotiateFlags = buf.readInt32LE(20);\n  msg.serverChallenge = buf.slice(24, 32);\n  msg.reserved = buf.slice(32, 40);\n\n  if (msg.negotiateFlags & flags.NTLM_NegotiateTargetInfo) {\n    msg.targetInfoLen = buf.readInt16LE(40);\n    msg.targetInfoMaxLen = buf.readInt16LE(42);\n    msg.targetInfoOffset = buf.readInt32LE(44);\n    msg.targetInfo = buf.slice(msg.targetInfoOffset, msg.targetInfoOffset + msg.targetInfoLen);\n  }\n\n  return msg;\n}\n\nfunction createType3Message(msg2, options) {\n  var nonce = msg2.serverChallenge;\n  var username = options.username;\n  var password = options.password;\n  var lm_password = options.lm_password;\n  var nt_password = options.nt_password;\n  var negotiateFlags = msg2.negotiateFlags;\n  var isUnicode = negotiateFlags & flags.NTLM_NegotiateUnicode;\n  var isNegotiateExtendedSecurity = negotiateFlags & flags.NTLM_NegotiateExtendedSecurity;\n  var BODY_LENGTH = 72;\n  var domainName = escape(options.domain.toUpperCase());\n  var workstation = escape(options.workstation.toUpperCase());\n  var workstationBytes, domainNameBytes, usernameBytes, encryptedRandomSessionKeyBytes;\n  var encryptedRandomSessionKey = \"\";\n\n  if (isUnicode) {\n    workstationBytes = new Buffer(workstation, 'utf16le');\n    domainNameBytes = new Buffer(domainName, 'utf16le');\n    usernameBytes = new Buffer(username, 'utf16le');\n    encryptedRandomSessionKeyBytes = new Buffer(encryptedRandomSessionKey, 'utf16le');\n  } else {\n    workstationBytes = new Buffer(workstation, 'ascii');\n    domainNameBytes = new Buffer(domainName, 'ascii');\n    usernameBytes = new Buffer(username, 'ascii');\n    encryptedRandomSessionKeyBytes = new Buffer(encryptedRandomSessionKey, 'ascii');\n  }\n\n  var lmChallengeResponse = calc_resp(lm_password != null ? lm_password : create_LM_hashed_password_v1(password), nonce);\n  var ntChallengeResponse = calc_resp(nt_password != null ? nt_password : create_NT_hashed_password_v1(password), nonce);\n\n  if (isNegotiateExtendedSecurity) {\n    var pwhash = nt_password != null ? nt_password : create_NT_hashed_password_v1(password);\n    var clientChallenge = \"\";\n\n    for (var i = 0; i < 8; i++) {\n      clientChallenge += String.fromCharCode(Math.floor(Math.random() * 256));\n    }\n\n    var clientChallengeBytes = new Buffer(clientChallenge, 'ascii');\n    var challenges = ntlm2sr_calc_resp(pwhash, nonce, clientChallengeBytes);\n    lmChallengeResponse = challenges.lmChallengeResponse;\n    ntChallengeResponse = challenges.ntChallengeResponse;\n  }\n\n  var signature = 'NTLMSSP\\0';\n  var pos = 0;\n  var buf = new Buffer(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length + lmChallengeResponse.length + ntChallengeResponse.length + encryptedRandomSessionKeyBytes.length);\n  buf.write(signature, pos, signature.length);\n  pos += signature.length;\n  buf.writeUInt32LE(3, pos);\n  pos += 4; // type 1\n\n  buf.writeUInt16LE(lmChallengeResponse.length, pos);\n  pos += 2; // LmChallengeResponseLen\n\n  buf.writeUInt16LE(lmChallengeResponse.length, pos);\n  pos += 2; // LmChallengeResponseMaxLen\n\n  buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length, pos);\n  pos += 4; // LmChallengeResponseOffset\n\n  buf.writeUInt16LE(ntChallengeResponse.length, pos);\n  pos += 2; // NtChallengeResponseLen\n\n  buf.writeUInt16LE(ntChallengeResponse.length, pos);\n  pos += 2; // NtChallengeResponseMaxLen\n\n  buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length + lmChallengeResponse.length, pos);\n  pos += 4; // NtChallengeResponseOffset\n\n  buf.writeUInt16LE(domainNameBytes.length, pos);\n  pos += 2; // DomainNameLen\n\n  buf.writeUInt16LE(domainNameBytes.length, pos);\n  pos += 2; // DomainNameMaxLen\n\n  buf.writeUInt32LE(BODY_LENGTH, pos);\n  pos += 4; // DomainNameOffset\n\n  buf.writeUInt16LE(usernameBytes.length, pos);\n  pos += 2; // UserNameLen\n\n  buf.writeUInt16LE(usernameBytes.length, pos);\n  pos += 2; // UserNameMaxLen\n\n  buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length, pos);\n  pos += 4; // UserNameOffset\n\n  buf.writeUInt16LE(workstationBytes.length, pos);\n  pos += 2; // WorkstationLen\n\n  buf.writeUInt16LE(workstationBytes.length, pos);\n  pos += 2; // WorkstationMaxLen\n\n  buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length, pos);\n  pos += 4; // WorkstationOffset\n\n  buf.writeUInt16LE(encryptedRandomSessionKeyBytes.length, pos);\n  pos += 2; // EncryptedRandomSessionKeyLen\n\n  buf.writeUInt16LE(encryptedRandomSessionKeyBytes.length, pos);\n  pos += 2; // EncryptedRandomSessionKeyMaxLen\n\n  buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length + lmChallengeResponse.length + ntChallengeResponse.length, pos);\n  pos += 4; // EncryptedRandomSessionKeyOffset\n\n  buf.writeUInt32LE(typeflags.NTLM_TYPE2_FLAGS, pos);\n  pos += 4; // NegotiateFlags\n\n  buf.writeUInt8(5, pos);\n  pos++; // ProductMajorVersion\n\n  buf.writeUInt8(1, pos);\n  pos++; // ProductMinorVersion\n\n  buf.writeUInt16LE(2600, pos);\n  pos += 2; // ProductBuild\n\n  buf.writeUInt8(0, pos);\n  pos++; // VersionReserved1\n\n  buf.writeUInt8(0, pos);\n  pos++; // VersionReserved2\n\n  buf.writeUInt8(0, pos);\n  pos++; // VersionReserved3\n\n  buf.writeUInt8(15, pos);\n  pos++; // NTLMRevisionCurrent\n\n  domainNameBytes.copy(buf, pos);\n  pos += domainNameBytes.length;\n  usernameBytes.copy(buf, pos);\n  pos += usernameBytes.length;\n  workstationBytes.copy(buf, pos);\n  pos += workstationBytes.length;\n  lmChallengeResponse.copy(buf, pos);\n  pos += lmChallengeResponse.length;\n  ntChallengeResponse.copy(buf, pos);\n  pos += ntChallengeResponse.length;\n  encryptedRandomSessionKeyBytes.copy(buf, pos);\n  pos += encryptedRandomSessionKeyBytes.length;\n  return 'NTLM ' + buf.toString('base64');\n}\n\nfunction create_LM_hashed_password_v1(password) {\n  // fix the password length to 14 bytes\n  password = password.toUpperCase();\n  var passwordBytes = new Buffer(password, 'ascii');\n  var passwordBytesPadded = new Buffer(14);\n  passwordBytesPadded.fill(\"\\0\");\n  var sourceEnd = 14;\n  if (passwordBytes.length < 14) sourceEnd = passwordBytes.length;\n  passwordBytes.copy(passwordBytesPadded, 0, 0, sourceEnd); // split into 2 parts of 7 bytes:\n\n  var firstPart = passwordBytesPadded.slice(0, 7);\n  var secondPart = passwordBytesPadded.slice(7);\n\n  function encrypt(buf) {\n    var key = insertZerosEvery7Bits(buf);\n    var des = crypto.createCipheriv('DES-ECB', key, '');\n    return des.update(\"KGS!@#$%\"); // page 57 in [MS-NLMP]);\n  }\n\n  var firstPartEncrypted = encrypt(firstPart);\n  var secondPartEncrypted = encrypt(secondPart);\n  return Buffer.concat([firstPartEncrypted, secondPartEncrypted]);\n}\n\nfunction insertZerosEvery7Bits(buf) {\n  var binaryArray = bytes2binaryArray(buf);\n  var newBinaryArray = [];\n\n  for (var i = 0; i < binaryArray.length; i++) {\n    newBinaryArray.push(binaryArray[i]);\n\n    if ((i + 1) % 7 === 0) {\n      newBinaryArray.push(0);\n    }\n  }\n\n  return binaryArray2bytes(newBinaryArray);\n}\n\nfunction bytes2binaryArray(buf) {\n  var hex2binary = {\n    0: [0, 0, 0, 0],\n    1: [0, 0, 0, 1],\n    2: [0, 0, 1, 0],\n    3: [0, 0, 1, 1],\n    4: [0, 1, 0, 0],\n    5: [0, 1, 0, 1],\n    6: [0, 1, 1, 0],\n    7: [0, 1, 1, 1],\n    8: [1, 0, 0, 0],\n    9: [1, 0, 0, 1],\n    A: [1, 0, 1, 0],\n    B: [1, 0, 1, 1],\n    C: [1, 1, 0, 0],\n    D: [1, 1, 0, 1],\n    E: [1, 1, 1, 0],\n    F: [1, 1, 1, 1]\n  };\n  var hexString = buf.toString('hex').toUpperCase();\n  var array = [];\n\n  for (var i = 0; i < hexString.length; i++) {\n    var hexchar = hexString.charAt(i);\n    array = array.concat(hex2binary[hexchar]);\n  }\n\n  return array;\n}\n\nfunction binaryArray2bytes(array) {\n  var binary2hex = {\n    '0000': 0,\n    '0001': 1,\n    '0010': 2,\n    '0011': 3,\n    '0100': 4,\n    '0101': 5,\n    '0110': 6,\n    '0111': 7,\n    '1000': 8,\n    '1001': 9,\n    '1010': 'A',\n    '1011': 'B',\n    '1100': 'C',\n    '1101': 'D',\n    '1110': 'E',\n    '1111': 'F'\n  };\n  var bufArray = [];\n\n  for (var i = 0; i < array.length; i += 8) {\n    if (i + 7 > array.length) break;\n    var binString1 = '' + array[i] + '' + array[i + 1] + '' + array[i + 2] + '' + array[i + 3];\n    var binString2 = '' + array[i + 4] + '' + array[i + 5] + '' + array[i + 6] + '' + array[i + 7];\n    var hexchar1 = binary2hex[binString1];\n    var hexchar2 = binary2hex[binString2];\n    var buf = new Buffer(hexchar1 + '' + hexchar2, 'hex');\n    bufArray.push(buf);\n  }\n\n  return Buffer.concat(bufArray);\n}\n\nfunction create_NT_hashed_password_v1(password) {\n  var buf = new Buffer(password, 'utf16le');\n  var md4 = crypto.createHash('md4');\n  md4.update(buf);\n  return new Buffer(md4.digest());\n}\n\nfunction calc_resp(password_hash, server_challenge) {\n  // padding with zeros to make the hash 21 bytes long\n  var passHashPadded = new Buffer(21);\n  passHashPadded.fill(\"\\0\");\n  password_hash.copy(passHashPadded, 0, 0, password_hash.length);\n  var resArray = [];\n  var des = crypto.createCipheriv('DES-ECB', insertZerosEvery7Bits(passHashPadded.slice(0, 7)), '');\n  resArray.push(des.update(server_challenge.slice(0, 8)));\n  des = crypto.createCipheriv('DES-ECB', insertZerosEvery7Bits(passHashPadded.slice(7, 14)), '');\n  resArray.push(des.update(server_challenge.slice(0, 8)));\n  des = crypto.createCipheriv('DES-ECB', insertZerosEvery7Bits(passHashPadded.slice(14, 21)), '');\n  resArray.push(des.update(server_challenge.slice(0, 8)));\n  return Buffer.concat(resArray);\n}\n\nfunction ntlm2sr_calc_resp(responseKeyNT, serverChallenge, clientChallenge) {\n  // padding with zeros to make the hash 16 bytes longer\n  var lmChallengeResponse = new Buffer(clientChallenge.length + 16);\n  lmChallengeResponse.fill(\"\\0\");\n  clientChallenge.copy(lmChallengeResponse, 0, 0, clientChallenge.length);\n  var buf = Buffer.concat([serverChallenge, clientChallenge]);\n  var md5 = crypto.createHash('md5');\n  md5.update(buf);\n  var sess = md5.digest();\n  var ntChallengeResponse = calc_resp(responseKeyNT, sess.slice(0, 8));\n  return {\n    lmChallengeResponse: lmChallengeResponse,\n    ntChallengeResponse: ntChallengeResponse\n  };\n}\n\nexports.createType1Message = createType1Message;\nexports.parseType2Message = parseType2Message;\nexports.createType3Message = createType3Message;\nexports.create_NT_hashed_password = create_NT_hashed_password_v1;\nexports.create_LM_hashed_password = create_LM_hashed_password_v1;","map":null,"metadata":{},"sourceType":"script"}