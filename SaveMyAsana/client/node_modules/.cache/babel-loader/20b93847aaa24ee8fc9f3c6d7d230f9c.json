{"ast":null,"code":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n */\n\"use strict\";\n\nvar HttpClient = require('./http'),\n    assert = require('assert'),\n    events = require('events'),\n    util = require('util'),\n    debug = require('debug')('node-soap'),\n    findPrefix = require('./utils').findPrefix,\n    _ = require('lodash'),\n    concatStream = require('concat-stream'),\n    BluebirdPromise = require(\"bluebird\"),\n    uuid4 = require('uuid/v4');\n\nvar nonIdentifierChars = /[^a-z$_0-9]/i;\n\nvar Client = function Client(wsdl, endpoint, options) {\n  events.EventEmitter.call(this);\n  options = options || {};\n  this.wsdl = wsdl;\n\n  this._initializeOptions(options);\n\n  this._initializeServices(endpoint);\n\n  this.httpClient = options.httpClient || new HttpClient(options);\n  var promiseOptions = {\n    multiArgs: true\n  };\n\n  if (options.overridePromiseSuffix) {\n    promiseOptions.suffix = options.overridePromiseSuffix;\n  }\n\n  BluebirdPromise.promisifyAll(this, promiseOptions);\n};\n\nutil.inherits(Client, events.EventEmitter);\n\nClient.prototype.addSoapHeader = function (soapHeader, name, namespace, xmlns) {\n  if (!this.soapHeaders) {\n    this.soapHeaders = [];\n  }\n\n  if (typeof soapHeader === 'object') {\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\n  }\n\n  return this.soapHeaders.push(soapHeader) - 1;\n};\n\nClient.prototype.changeSoapHeader = function (index, soapHeader, name, namespace, xmlns) {\n  if (!this.soapHeaders) {\n    this.soapHeaders = [];\n  }\n\n  if (typeof soapHeader === 'object') {\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\n  }\n\n  this.soapHeaders[index] = soapHeader;\n};\n\nClient.prototype.getSoapHeaders = function () {\n  return this.soapHeaders;\n};\n\nClient.prototype.clearSoapHeaders = function () {\n  this.soapHeaders = null;\n};\n\nClient.prototype.addHttpHeader = function (name, value) {\n  if (!this.httpHeaders) {\n    this.httpHeaders = {};\n  }\n\n  this.httpHeaders[name] = value;\n};\n\nClient.prototype.getHttpHeaders = function () {\n  return this.httpHeaders;\n};\n\nClient.prototype.clearHttpHeaders = function () {\n  this.httpHeaders = {};\n};\n\nClient.prototype.addBodyAttribute = function (bodyAttribute, name, namespace, xmlns) {\n  if (!this.bodyAttributes) {\n    this.bodyAttributes = [];\n  }\n\n  if (typeof bodyAttribute === 'object') {\n    var composition = '';\n    Object.getOwnPropertyNames(bodyAttribute).forEach(function (prop, idx, array) {\n      composition += ' ' + prop + '=\"' + bodyAttribute[prop] + '\"';\n    });\n    bodyAttribute = composition;\n  }\n\n  if (bodyAttribute.substr(0, 1) !== ' ') bodyAttribute = ' ' + bodyAttribute;\n  this.bodyAttributes.push(bodyAttribute);\n};\n\nClient.prototype.getBodyAttributes = function () {\n  return this.bodyAttributes;\n};\n\nClient.prototype.clearBodyAttributes = function () {\n  this.bodyAttributes = null;\n};\n\nClient.prototype.setEndpoint = function (endpoint) {\n  this.endpoint = endpoint;\n\n  this._initializeServices(endpoint);\n};\n\nClient.prototype.describe = function () {\n  var types = this.wsdl.definitions.types;\n  return this.wsdl.describeServices();\n};\n\nClient.prototype.setSecurity = function (security) {\n  this.security = security;\n};\n\nClient.prototype.setSOAPAction = function (SOAPAction) {\n  this.SOAPAction = SOAPAction;\n};\n\nClient.prototype._initializeServices = function (endpoint) {\n  var definitions = this.wsdl.definitions,\n      services = definitions.services;\n\n  for (var name in services) {\n    this[name] = this._defineService(services[name], endpoint);\n  }\n};\n\nClient.prototype._initializeOptions = function (options) {\n  this.streamAllowed = options.stream;\n  this.normalizeNames = options.normalizeNames;\n  this.wsdl.options.attributesKey = options.attributesKey || 'attributes';\n  this.wsdl.options.envelopeKey = options.envelopeKey || 'soap';\n  this.wsdl.options.preserveWhitespace = !!options.preserveWhitespace;\n\n  if (options.ignoredNamespaces !== undefined) {\n    if (options.ignoredNamespaces.override !== undefined) {\n      if (options.ignoredNamespaces.override === true) {\n        if (options.ignoredNamespaces.namespaces !== undefined) {\n          this.wsdl.options.ignoredNamespaces = options.ignoredNamespaces.namespaces;\n        }\n      }\n    }\n  }\n\n  if (options.overrideRootElement !== undefined) {\n    this.wsdl.options.overrideRootElement = options.overrideRootElement;\n  }\n\n  this.wsdl.options.forceSoap12Headers = !!options.forceSoap12Headers;\n};\n\nClient.prototype._defineService = function (service, endpoint) {\n  var ports = service.ports,\n      def = {};\n\n  for (var name in ports) {\n    def[name] = this._definePort(ports[name], endpoint ? endpoint : ports[name].location);\n  }\n\n  return def;\n};\n\nClient.prototype._definePort = function (port, endpoint) {\n  var location = endpoint,\n      binding = port.binding,\n      methods = binding.methods,\n      def = {};\n\n  for (var name in methods) {\n    def[name] = this._defineMethod(methods[name], location);\n    var methodName = this.normalizeNames ? name.replace(nonIdentifierChars, '_') : name;\n    this[methodName] = def[name];\n  }\n\n  return def;\n};\n\nClient.prototype._defineMethod = function (method, location) {\n  var self = this;\n  var temp;\n  return function (args, callback, options, extraHeaders) {\n    if (typeof args === 'function') {\n      callback = args;\n      args = {};\n    } else if (typeof options === 'function') {\n      temp = callback;\n      callback = options;\n      options = temp;\n    } else if (typeof extraHeaders === 'function') {\n      temp = callback;\n      callback = extraHeaders;\n      extraHeaders = options;\n      options = temp;\n    }\n\n    self._invoke(method, args, location, function (error, result, rawResponse, soapHeader, rawRequest) {\n      callback(error, result, rawResponse, soapHeader, rawRequest);\n    }, options, extraHeaders);\n  };\n};\n\nClient.prototype._invoke = function (method, args, location, callback, options, extraHeaders) {\n  var self = this,\n      name = method.$name,\n      input = method.input,\n      output = method.output,\n      style = method.style,\n      defs = this.wsdl.definitions,\n      envelopeKey = this.wsdl.options.envelopeKey,\n      ns = defs.$targetNamespace,\n      encoding = '',\n      message = '',\n      xml = null,\n      req = null,\n      soapAction,\n      alias = findPrefix(defs.xmlns, ns),\n      headers = {\n    \"Content-Type\": \"text/xml; charset=utf-8\"\n  },\n      xmlnsSoap = \"xmlns:\" + envelopeKey + \"=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\";\n\n  if (this.wsdl.options.forceSoap12Headers) {\n    headers[\"Content-Type\"] = \"application/soap+xml; charset=utf-8\";\n    xmlnsSoap = \"xmlns:\" + envelopeKey + \"=\\\"http://www.w3.org/2003/05/soap-envelope\\\"\";\n  }\n\n  if (this.SOAPAction) {\n    soapAction = this.SOAPAction;\n  } else if (method.soapAction !== undefined && method.soapAction !== null) {\n    soapAction = method.soapAction;\n  } else {\n    soapAction = (ns.lastIndexOf(\"/\") !== ns.length - 1 ? ns + \"/\" : ns) + name;\n  }\n\n  if (!this.wsdl.options.forceSoap12Headers) {\n    headers.SOAPAction = '\"' + soapAction + '\"';\n  }\n\n  options = options || {}; //Add extra headers\n\n  for (var header in this.httpHeaders) {\n    headers[header] = this.httpHeaders[header];\n  }\n\n  for (var attr in extraHeaders) {\n    headers[attr] = extraHeaders[attr];\n  } // Allow the security object to add headers\n\n\n  if (self.security && self.security.addHeaders) self.security.addHeaders(headers);\n  if (self.security && self.security.addOptions) self.security.addOptions(options);\n\n  if (style === 'rpc' && (input.parts || input.name === \"element\" || args === null)) {\n    assert.ok(!style || style === 'rpc', 'invalid message definition for document style binding');\n    message = self.wsdl.objectToRpcXML(name, args, alias, ns, input.name !== \"element\");\n    method.inputSoap === 'encoded' && (encoding = 'soap:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" ');\n  } else {\n    assert.ok(!style || style === 'document', 'invalid message definition for rpc style binding'); // pass `input.$lookupType` if `input.$type` could not be found\n\n    message = self.wsdl.objectToDocumentXML(input.$name, args, input.targetNSAlias, input.targetNamespace, input.$type || input.$lookupType);\n  }\n\n  xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" + \"<\" + envelopeKey + \":Envelope \" + xmlnsSoap + \" \" + \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" + encoding + this.wsdl.xmlnsInEnvelope + '>' + (self.soapHeaders || self.security ? \"<\" + envelopeKey + \":Header>\" + (self.soapHeaders ? self.soapHeaders.join(\"\\n\") : \"\") + (self.security && !self.security.postProcess ? self.security.toXML() : \"\") + \"</\" + envelopeKey + \":Header>\" : '') + \"<\" + envelopeKey + \":Body\" + (self.bodyAttributes ? self.bodyAttributes.join(' ') : '') + (self.security && self.security.postProcess ? ' Id=\"_0\"' : '') + \">\" + message + \"</\" + envelopeKey + \":Body>\" + \"</\" + envelopeKey + \":Envelope>\";\n\n  if (self.security && self.security.postProcess) {\n    xml = self.security.postProcess(xml, envelopeKey);\n  }\n\n  if (options && options.postProcess) {\n    xml = options.postProcess(xml);\n  }\n\n  self.lastMessage = message;\n  self.lastRequest = xml;\n  self.lastEndpoint = location;\n  var eid = options.exchangeId || uuid4();\n  self.emit('message', message, eid);\n  self.emit('request', xml, eid);\n\n  var tryJSONparse = function tryJSONparse(body) {\n    try {\n      return JSON.parse(body);\n    } catch (err) {\n      return undefined;\n    }\n  };\n\n  if (this.streamAllowed && typeof self.httpClient.requestStream === 'function') {\n    callback = _.once(callback);\n    var startTime = Date.now();\n    req = self.httpClient.requestStream(location, xml, headers, options, self);\n    self.lastRequestHeaders = req.headers;\n\n    var onError = function onError(err) {\n      self.lastResponse = null;\n      self.lastResponseHeaders = null;\n      self.lastElapsedTime = null;\n      self.emit('response', null, null, eid);\n      callback(err, undefined, undefined, undefined, xml);\n    };\n\n    req.on('error', onError);\n    req.on('response', function (response) {\n      response.on('error', onError); // When the output element cannot be looked up in the wsdl, play it safe and\n      // don't stream\n\n      if (response.statusCode !== 200 || !output || !output.$lookupTypes) {\n        response.pipe(concatStream({\n          encoding: 'string'\n        }, function (body) {\n          self.lastResponse = body;\n          self.lastResponseHeaders = response && response.headers;\n          self.lastElapsedTime = Date.now() - startTime;\n          self.emit('response', body, response, eid);\n          return parseSync(body, response);\n        }));\n        return;\n      }\n\n      self.wsdl.xmlToObject(response, function (error, obj) {\n        self.lastResponse = response;\n        self.lastResponseHeaders = response && response.headers;\n        self.lastElapsedTime = Date.now() - startTime;\n        self.emit('response', '<stream>', response, eid);\n\n        if (error) {\n          error.response = response;\n          error.body = '<stream>';\n          self.emit('soapError', error, eid);\n          return callback(error, response, undefined, undefined, xml);\n        }\n\n        return finish(obj, '<stream>', response);\n      });\n    });\n    return;\n  }\n\n  req = self.httpClient.request(location, xml, function (err, response, body) {\n    self.lastResponse = body;\n    self.lastResponseHeaders = response && response.headers;\n    self.lastElapsedTime = response && response.elapsedTime;\n    self.emit('response', body, response, eid);\n\n    if (err) {\n      callback(err, undefined, undefined, undefined, xml);\n    } else {\n      return parseSync(body, response);\n    }\n  }, headers, options, self);\n\n  function parseSync(body, response) {\n    var obj;\n\n    try {\n      obj = self.wsdl.xmlToObject(body);\n    } catch (error) {\n      //  When the output element cannot be looked up in the wsdl and the body is JSON\n      //  instead of sending the error, we pass the body in the response.\n      if (!output || !output.$lookupTypes) {\n        debug('Response element is not present. Unable to convert response xml to json.'); //  If the response is JSON then return it as-is.\n\n        var json = _.isObject(body) ? body : tryJSONparse(body);\n\n        if (json) {\n          return callback(null, response, json, undefined, xml);\n        }\n      }\n\n      error.response = response;\n      error.body = body;\n      self.emit('soapError', error, eid);\n      return callback(error, response, body, undefined, xml);\n    }\n\n    return finish(obj, body, response);\n  }\n\n  function finish(obj, body, response) {\n    var result;\n\n    if (!output) {\n      // one-way, no output expected\n      return callback(null, null, body, obj.Header, xml);\n    } // If it's not HTML and Soap Body is empty\n\n\n    if (!obj.html && !obj.Body) {\n      return callback(null, obj, body, obj.Header);\n    }\n\n    if (typeof obj.Body !== 'object') {\n      var error = new Error('Cannot parse response');\n      error.response = response;\n      error.body = body;\n      return callback(error, obj, body, undefined, xml);\n    }\n\n    result = obj.Body[output.$name]; // RPC/literal response body may contain elements with added suffixes I.E.\n    // 'Response', or 'Output', or 'Out'\n    // This doesn't necessarily equal the ouput message name. See WSDL 1.1 Section 2.4.5\n\n    if (!result) {\n      result = obj.Body[output.$name.replace(/(?:Out(?:put)?|Response)$/, '')];\n    }\n\n    if (!result) {\n      ['Response', 'Out', 'Output'].forEach(function (term) {\n        if (obj.Body.hasOwnProperty(name + term)) {\n          return result = obj.Body[name + term];\n        }\n      });\n    }\n\n    callback(null, result, body, obj.Header, xml);\n  } // Added mostly for testability, but possibly useful for debugging\n\n\n  if (req && req.headers && !options.ntlm) //fixes an issue when req or req.headers is undefined, doesn't apply to ntlm requests\n    self.lastRequestHeaders = req.headers;\n};\n\nexports.Client = Client;","map":null,"metadata":{},"sourceType":"script"}